<!DOCTYPE html>
<html lang="en" class=""> <!-- 'dark' class will be toggled here -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hiring Coding Test - TESTIFY</title>
    <link rel="icon" type="image/png" href="https://res.cloudinary.com/dpz44zf0z/image/upload/v1761650455/TESTIFY-SECURE_TEST_bpv8vp.png">

    <!-- Scripts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/material-darker.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/neo.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.4/purify.min.js"></script>

    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none; -ms-user-select: none; user-select: none;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #f8fafc; border-radius: 10px;}
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px;}
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .dark ::-webkit-scrollbar-track { background: #0f172a; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* CodeMirror sizing and styling */
        .CodeMirror { height: 100%; font-size: 14px; border-radius: 0 0 0.5rem 0.5rem; line-height: 1.5; }

        /* Light theme overrides */
        .cm-s-neo.CodeMirror { background-color: #f8fafc; color: #1e293b; }
        .cm-s-neo .CodeMirror-gutters { background-color: #f1f5f9; border-right: 1px solid #e2e8f0; }
        .cm-s-neo .CodeMirror-linenumber { color: #64748b; }
        .cm-s-neo .CodeMirror-cursor { border-left: 1px solid #0f172a; }
        .cm-s-neo span.cm-comment { color: #94a3b8; }
        .cm-s-neo span.cm-keyword { color: #6366f1; }
        .cm-s-neo span.cm-string { color: #059669; }
        .cm-s-neo span.cm-number { color: #db2777; }
        .cm-s-neo span.cm-atom { color: #6366f1; }
        .cm-s-neo span.cm-operator { color: #1e293b; }
        .cm-s-neo span.cm-variable { color: #1e293b; }
        .cm-s-neo span.cm-property { color: #ea580c; }
        .cm-s-neo span.cm-def { color: #2563eb; }
        .cm-s-neo .CodeMirror-activeline-background { background-color: #f1f5f9; }
        .cm-s-neo .CodeMirror-matchingbracket { color: #fff; background-color: #6366f1; }

        /* Dark theme overrides */
        .cm-s-material-darker.CodeMirror { background-color: #0f172a; }

        /* Prose styles for problem description */
        .prose-custom h2 {
            font-size: 1.5rem; font-weight: 600; color: #111827;
            margin-top: 2em; margin-bottom: 0.75em; border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
        .prose-custom h3 {
            font-size: 1.25rem; font-weight: 600; color: #1f2937;
            margin-top: 1.5em; margin-bottom: 0.5em;
        }
        .prose-custom p, .prose-custom li {
            color: #1f2937; line-height: 1.7; font-size: 1rem;
        }
        .prose-custom pre {
            white-space: pre-wrap; word-wrap: break-word; background-color: #f3f4f6;
            color: #1f2937; padding: 1em; border-radius: 0.375rem;
            font-size: 0.9em; border: 1px solid #e5e7eb;
        }
        .prose-custom code:not(pre > code) {
            background-color: #e5e7eb; color: #c026d3; padding: 0.2em 0.4em;
            border-radius: 0.25rem; font-size: 0.9em; font-weight: 500;
        }
        .prose-custom pre > code { background-color: transparent; padding: 0; border-radius: 0; font-size: inherit; color: inherit; }

        /* Dark mode prose */
        .dark .prose-custom-dark h2 { color: #f1f5f9; border-bottom-color: #334155; }
        .dark .prose-custom-dark h3 { color: #e2e8f0; }
        .dark .prose-custom-dark p, .dark .prose-custom-dark li { color: #e2e8f0; }
        .dark .prose-custom-dark pre { background-color: #1e293b; color: #e2e8f0; border-color: #334155; }
        .dark .prose-custom-dark code:not(pre > code) { background-color: #334155; color: #f0abfc; }

        /* Circular Timer SVG */
        .timer-circle-bg { stroke: #e5e7eb; }
        .timer-circle-fg {
            stroke: #4f46e5; stroke-linecap: round;
            transform-origin: 50% 50%; transform: rotate(-90deg);
            transition: stroke-dashoffset 1s linear;
        }
        .dark .timer-circle-bg { stroke: #334155; }
        .dark .timer-circle-fg { stroke: #818cf8; }

        /* Spinner */
        .spinner { border-top-color: #4f46e5; animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* Message Box */
        .message-box {
            position: fixed; top: 20px; left: 50%; padding: 0.8rem 1.5rem;
            border-radius: 0.5rem; color: white; font-weight: 500;
            z-index: 1000; opacity: 0; transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); font-size: 0.9rem;
            transform: translateY(-20px) translateX(-50%);
        }
        .message-box.show { opacity: 1; transform: translateY(0) translateX(-50%); }
        .message-box.error { background-color: #ef4444; }
        .message-box.success { background-color: #10b981; }
        .message-box.warning { background-color: #f59e0b; }
        .message-box.info { background-color: #3b82f6; }

        /* Modal Styling */
        .modal-overlay {
            position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(4px); display: flex; align-items: center;
            justify-content: center; z-index: 50; opacity: 0;
            transition: opacity 0.3s ease-out; pointer-events: none;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }
        .modal-container {
            background-color: white; border-radius: 0.75rem; padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            width: 90%; max-width: 500px; transform: scale(0.95);
            transition: transform 0.3s ease-out;
        }
        .dark .modal-container { background-color: #1e293b; }
        .modal-overlay.show .modal-container { transform: scale(1); }

        /* Section Navigation Styles (Inside Sidebar) */
        .section-nav-header { border-bottom: 1px solid #e5e7eb; }
        .dark .section-nav-header { border-bottom-color: #334155; }
        .section-title { cursor: pointer; }
        .section-problems-list { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .section-container.open .section-problems-list { max-height: 500px; }
        .section-container.open .chevron-icon { transform: rotate(180deg); }

        /* Problem Nav Button */
        .problem-nav-btn {
            display: block; width: 100%; text-align: left;
            padding: 0.5rem 0.75rem; font-size: 0.875rem; border-radius: 0.375rem;
            transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out;
            position: relative; padding-left: 1.75rem; border: 1px solid transparent;
        }
        .problem-nav-btn:hover { background-color: #f3f4f6; }
        .dark .problem-nav-btn:hover { background-color: #334155; }
        .problem-nav-btn.active {
            background-color: #e0e7ff; color: #4338ca; font-weight: 600;
        }
        .dark .problem-nav-btn.active {
            background-color: #3730a3; color: #e0e7ff;
        }

        /* Status Indicators (Circular) */
        .problem-nav-btn::before {
            content: ''; position: absolute; left: 0.75rem; top: 50%;
            transform: translateY(-50%); width: 0.5rem; height: 0.5rem;
            border-radius: 9999px; transition: background-color 0.15s ease-in-out;
        }
        .problem-nav-btn.status-pending::before { background-color: #9ca3af; }
        .problem-nav-btn.status-attempted::before { background-color: #f59e0b; }
        .problem-nav-btn.status-solved::before { background-color: #10b981; }
        
        /* NEW: Locked section styles */
        .problem-nav-btn.locked {
            color: #9ca3af; /* gray-400 */
            background-color: #f3f4f6; /* gray-100 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        .dark .problem-nav-btn.locked {
            color: #475569; /* slate-600 */
            background-color: #1e293b; /* slate-800 */
        }
        .problem-nav-btn.locked:hover {
            background-color: #f3f4f6; /* gray-100 */
        }
        .dark .problem-nav-btn.locked:hover {
            background-color: #1e293b; /* slate-800 */
        }
        .problem-nav-btn.locked::before {
            background-color: #ef4444; /* red-500 */
        }
        .section-timer-info.locked {
            color: #ef4444;
            text-decoration: line-through;
        }
        
        /* Network Status Indicator */
        #network-status { transition: opacity 0.5s ease-out; }
    </style>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: { 50: '#f8fafc', 100: '#f1f5f9', 200: '#e2e8f0', 300: '#cbd5e1', 400: '#94a3b8', 500: '#64748b', 600: '#475569', 700: '#334155', 800: '#1e293b', 900: '#0f172a', },
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
</head>

<body class="bg-gray-50 dark:bg-slate-900 text-gray-900 dark:text-gray-100 min-h-screen">

    <!-- Message Box Container -->
    <div id="message-box-container"></div>
    <!-- Network Status Indicator -->
    <div id="network-status" class="opacity-0 fixed bottom-4 right-4 px-3 py-1.5 rounded-lg text-sm font-medium z-50 transition-opacity duration-500 border"></div>

    <!-- Main container for initial loading -->
    <div id="main-content" class="min-h-screen flex items-center justify-center p-4">
        <!-- Loader -->
        <div id="loader" class="text-center p-8 bg-white dark:bg-slate-800 rounded-lg shadow-xl">
            <svg class="animate-spin h-10 w-10 text-indigo-600 mx-auto mb-4 spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p class="text-xl font-semibold text-gray-700 dark:text-slate-300">Initializing Secure Test...</p>
        </div>
        <!-- Error Message Display -->
        <div id="error-message" class="hidden text-center bg-white dark:bg-slate-800 p-8 rounded-lg shadow-xl max-w-lg">
            <i class="fas fa-exclamation-triangle text-4xl text-red-500 mb-4"></i>
            <h2 class="text-2xl font-bold text-red-600 dark:text-red-500 mb-2">Initialization Failed</h2>
            <p class="text-gray-600 dark:text-slate-400"></p>
        </div>
    </div>

    <!-- Test Environment (Initially Hidden) -->
    <div id="test-environment" class="hidden h-screen w-screen flex flex-col">

        <!-- Header -->
        <header class="flex-shrink-0 h-14 bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 flex items-center justify-between px-4 md:px-6 z-20">
            <!-- Left: Logo & Title -->
            <div class="flex items-center gap-3 min-w-0">
                <!-- Problems Toggle Button -->
                <button id="toggle-problems-btn" class="p-2 rounded-md text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
                    <i class="fas fa-bars"></i>
                </button>
                <img src="https://res.cloudinary.com/dpz44zf0z/image/upload/v1761650455/TESTIFY-SECURE_TEST_bpv8vp.png" alt="Testify Logo" class="h-8 w-8 rounded-md object-contain">
                <span class="text-gray-400 dark:text-slate-600 text-2xl font-light hidden md:block">/</span>
                <span id="test-title-header" class="text-lg font-semibold text-gray-800 dark:text-slate-200 truncate hidden md:block">Coding Test</span>
            </div>

             <!-- Center: Current Problem Title -->
            <div class="flex-1 text-center px-4">
                 <span id="problem-title-header" class="text-base font-medium text-gray-700 dark:text-slate-300 truncate">Select a Problem</span>
            </div>

            <!-- Right: Timer, Buttons, Dark Mode -->
            <div class="flex items-center gap-4">
                
                <!-- NEW: Section Timer Note (Hidden by default) -->
                <p id="section-timer-note" class="hidden text-xs font-semibold text-indigo-600 dark:text-indigo-400 animate-pulse">
                    Section Based Timer Applied
                </p>

                <!-- NEW: Updated Timer Block (matches screenshot) -->
                <div class="flex items-center gap-2">
                    <div class="relative w-11 h-11">
                        <svg class="w-full h-full" viewBox="0 0 36 36">
                            <path class="timer-circle-bg stroke-2" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" fill="none" stroke-width="3"></path>
                            <path id="timer-fg" class="timer-circle-fg stroke-2" stroke-dasharray="100, 100" stroke-dashoffset="0" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" fill="none" stroke-width="3"></path>
                        </svg>
                        <div id="timer-text" class="absolute inset-0 flex items-center justify-center text-xs font-bold text-gray-700 dark:text-slate-300">00:00</div>
                    </div>
                    <!-- NEW: Timer Label -->
                    <span id="timer-label" class="text-sm font-semibold uppercase text-gray-500 dark:text-slate-400 tracking-wider">Total Time</span>
                </div>
                <!-- END: Updated Timer Block -->


                <!-- Run Button -->
                <button id="run-code-btn" class="px-3 py-2 md:px-4 text-sm font-medium rounded-lg text-white bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 shadow-md transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:bg-gray-400 dark:disabled:bg-slate-600 disabled:cursor-not-allowed disabled:from-gray-400 disabled:to-gray-400 disabled:shadow-none disabled:transform-none flex items-center justify-center transition-all duration-150">
                    <svg id="run-spinner" class="animate-spin -ml-1 mr-2 h-4 w-4 text-white hidden spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    <i id="run-icon" class="fas fa-play mr-1.5"></i>
                    <span id="run-code-btn-text">Run</span>
                </button>

                <!-- Submit Button -->
                <button id="submit-test-btn" class="px-3 py-2 md:px-4 text-sm font-medium rounded-lg text-white bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 shadow-md transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 disabled:bg-gray-400 dark:disabled:bg-slate-600 disabled:cursor-not-allowed disabled:from-gray-400 disabled:to-gray-400 disabled:shadow-none disabled:transform-none flex items-center justify-center transition-all duration-150">
                    <svg id="submit-spinner" class="animate-spin -ml-1 mr-2 h-4 w-4 text-white hidden spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    <i id="submit-icon" class="fas fa-paper-plane mr-1.5"></i>
                    <span id="submit-btn-text">Submit</span>
                </button>

                 <!-- Dark Mode Toggle -->
                <button id="dark-mode-toggle" class="p-2 rounded-md text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
                    <i id="theme-icon" class="fas fa-sun"></i>
                </button>
            </div>
        </header>

        <!-- Main Content Area (Split Left/Right) -->
        <div class="flex-1 flex flex-col md:flex-row overflow-hidden p-4 md:p-6 gap-4 md:gap-6">

            <!-- Left Panel: Problem Description -->
            <aside class="w-full md:w-2/5 h-full flex flex-col bg-white dark:bg-slate-800 rounded-lg shadow-lg overflow-hidden">
                <!-- Problem Description Area -->
                <div class="flex-1 flex flex-col overflow-hidden">
                    <!-- Tabs -->
                    <div class="flex-shrink-0 flex items-center border-b border-gray-200 dark:border-slate-700">
                        <button data-tab="problem" class="problem-tab active-tab px-4 py-3 text-sm font-semibold text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600 dark:border-indigo-400">
                            <i class="fas fa-file-alt mr-1.5"></i> Description
                        </button>
                        <button data-tab="notes" class="problem-tab inactive-tab px-4 py-3 text-sm font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-200">
                            <i class="fas fa-pencil-alt mr-1.5"></i> Scratchpad
                        </button>
                    </div>
                    <!-- Tab Content -->
                    <div class="flex-1 overflow-y-auto">
                        <!-- Problem Description Content -->
                        <div id="problem-content" class="problem-tab-content p-5 md:p-6 relative">
                            <div id="problem-spinner" class="absolute inset-0 flex items-center justify-center bg-white dark:bg-slate-800 bg-opacity-75 dark:bg-opacity-75 z-10 hidden">
                                <svg class="animate-spin h-8 w-8 text-indigo-600 spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                            </div>
                            <div id="problem-details-container" class="prose-custom dark:prose-custom-dark max-w-none">
                                <!-- Status dot next to title -->
                                <h2 id="problem-title-main" class="!mt-0 flex justify-between items-center">
                                    <div class="flex items-center gap-3">
                                        <span id="problem-status-main-dot" class="w-3 h-3 rounded-full bg-gray-400 flex-shrink-0"></span>
                                        <span>Select a problem</span>
                                    </div>
                                    <span id="problem-points-badge" class="hidden text-xs font-bold text-white bg-indigo-600 dark:bg-indigo-500 px-2.5 py-1 rounded-full"></span>
                                </h2>
                                <p id="problem-difficulty-main" class="text-sm font-semibold text-gray-500 dark:text-slate-400"></p>
                                
                                <!-- NEW: Section Info Block (replaces old screenshot) -->
                                <!-- This block is now hidden unless section timers are on -->
                                <div id="section-info-block" class="hidden bg-indigo-50 dark:bg-slate-700 border border-indigo-200 dark:border-slate-600 rounded-lg p-4 my-4">
                                    <h4 id="section-info-title" class="text-sm font-semibold text-indigo-800 dark:text-indigo-200">Section: Array Puzzles</h4>
                                    <!-- REMOVED: Qualifying marks -->
                                    <p class="text-sm text-indigo-700 dark:text-indigo-300">
                                        Time Remaining: <span id="section-info-timer" class="font-bold tabular-nums">00:00</span>
                                    </p>
                                </div>
                                <!-- END: Section Info Block -->

                                <div id="problem-details-content">
                                    <p class="text-center text-gray-500 dark:text-slate-400 italic mt-10">Select a problem from the navigation panel to view details.</p>
                                </div>
                            </div>
                        </div>
                        <!-- Scratchpad Content -->
                        <div id="notes-content" class="problem-tab-content hidden h-full">
                            <textarea id="scratchpad" class="w-full h-full p-4 md:p-6 bg-transparent text-gray-800 dark:text-slate-200 border-0 focus:ring-0 resize-none outline-none" placeholder="Your private scratchpad. Content is saved locally..."></textarea>
                        </div>
                    </div>
                </div>
            </aside>

             <!-- Right Panel: Editor & Output -->
            <main class="w-full md:w-3/5 h-full flex flex-col bg-white dark:bg-slate-800 rounded-lg shadow-lg overflow-hidden">
                <!-- Editor Area -->
                <div class="flex-1 flex flex-col overflow-hidden relative">
                    <!-- Editor Header -->
                    <div class="flex-shrink-0 h-14 flex justify-between items-center px-4 bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 rounded-t-lg">
                        <select id="language-select" class="text-sm rounded-md border-gray-300 dark:border-slate-600 bg-gray-50 dark:bg-slate-700 text-gray-900 dark:text-slate-100 focus:ring-indigo-500 focus:border-indigo-500">
                            <!-- Languages populated by JS -->
                        </select>
                        <!-- Dark mode toggle moved to main header -->
                    </div>
                    <!-- Editor -->
                    <div class="flex-1 relative overflow-hidden">
                        <textarea id="code-editor"></textarea>
                        <!-- NEW: Editor Lock Overlay -->
                        <div id="editor-locked-overlay" class="hidden absolute inset-0 bg-gray-400/30 dark:bg-slate-900/50 backdrop-blur-sm z-20 flex items-center justify-center text-center p-4">
                            <div class="bg-white dark:bg-slate-700 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-slate-600">
                                <i class="fas fa-lock text-3xl text-red-500 mb-3"></i>
                                <h4 id="editor-lock-message" class="text-lg font-semibold text-gray-800 dark:text-slate-100">Time is up for this section.</h4>
                                <p class="text-sm text-gray-600 dark:text-slate-400">Please move to a problem in another section.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Output Area -->
                <div class="flex-shrink-0 flex flex-col h-2/5 md:h-1/3 max-h-[50%] border-t border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 overflow-hidden" style="resize: vertical; min-height: 150px;">
                    <!-- Output Tabs -->
                    <div id="output-tab-bar" class="flex-shrink-0 flex items-center border-b border-gray-200 dark:border-slate-700">
                        <button data-tab="testcases" class="output-tab active-tab px-4 py-2.5 text-sm font-semibold text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600 dark:border-indigo-400">
                            <i class="fas fa-tasks mr-1.5"></i> Test Cases
                        </button>
                        <button data-tab="console" class="output-tab inactive-tab px-4 py-2.5 text-sm font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-200">
                            <i class="fas fa-terminal mr-1.5"></i> Console
                        </button>
                    </div>
                    <!-- Output Content -->
                    <div class="flex-1 overflow-y-auto">
                        <!-- Test Cases Content -->
                        <div id="testcases-content" class="output-tab-content p-4">
                            <div id="test-case-results" class="flex flex-col gap-3">
                                <div id="results-placeholder" class="flex items-center justify-center h-24 text-gray-500 dark:text-slate-400 italic">
                                    Run code to see test case results here.
                                </div>
                            </div>
                        </div>
                        <!-- Console Content -->
                        <div id="console-content" class="output-tab-content hidden p-4 h-full">
                            <pre id="output-console" class="text-sm font-mono h-full text-gray-700 dark:text-slate-300"><div id="output-placeholder" class="flex items-center justify-center h-full text-gray-500 dark:text-slate-400 italic">Console output will appear here...</div></pre>
                        </div>
                    </div>
                </div>
            </main>
        </div>

        <!-- Footer -->
        <footer class="flex-shrink-0 h-10 bg-white dark:bg-slate-800 border-t border-gray-200 dark:border-slate-700 flex items-center justify-center px-4 md:px-6 z-10">
            <p class="text-xs text-gray-500 dark:text-slate-400">
                 Copyright Â© <span id="current-year"></span> Testify - Secure Test | Xeta Solutions. All rights reserved.
            </p>
        </footer>
    </div> <!-- End Test Environment -->

    <!-- Problems Sidebar (Off-canvas) -->
    <div id="problems-overlay" class="fixed inset-0 bg-black/50 z-30 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out"></div>
    <div id="problems-sidebar" class="fixed top-0 left-0 h-full w-full max-w-xs sm:w-72 bg-white dark:bg-slate-800 z-40 transform -translate-x-full transition-transform duration-300 ease-in-out flex flex-col shadow-xl">
        <div class="flex items-center justify-between p-3 border-b border-gray-200 dark:border-slate-700">
            <h3 class="text-sm font-semibold uppercase text-gray-500 dark:text-slate-400">Sections & Problems</h3>
            <button id="close-problems-btn" class="p-2 rounded-md text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto p-3">
             <div id="section-navigation-container" class="space-y-3">
                  <p class="text-xs text-center text-gray-400 dark:text-slate-500 py-4">Loading sections...</p>
             </div>
        </div>
        <!-- NEW: Total Timer in Sidebar -->
        <div id="total-timer-block" class="hidden flex-shrink-0 p-3 border-t border-gray-200 dark:border-slate-700">
            <div class="bg-indigo-100 dark:bg-slate-700 rounded-lg p-2 flex items-center justify-between">
                <span class="text-sm font-semibold text-indigo-800 dark:text-indigo-200">Total Time Left:</span>
                <span id="total-timer-text" class="text-sm font-bold text-indigo-800 dark:text-indigo-200 tabular-nums">00:00:00</span>
            </div>
        </div>
    </div>


    <!-- Modals -->
    <div id="processing-modal" class="modal-overlay">
        <div class="modal-container text-center">
            <svg id="processing-spinner" class="animate-spin h-8 w-8 text-indigo-600 mx-auto mb-4 spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p id="processing-message" class="text-lg font-medium text-gray-700 dark:text-slate-300">Processing...</p>
            <p id="processing-error-message" class="text-sm text-red-600 dark:text-red-400 mt-2 hidden"></p>
        </div>
    </div>
    <div id="confirm-submit-modal" class="modal-overlay">
        <div class="modal-container">
            <h3 class="text-lg font-bold text-gray-900 dark:text-slate-100 mb-4">Confirm Submission</h3>
            <p id="modal-confirm-message" class="text-sm text-gray-600 dark:text-slate-400 mb-6">Are you sure you want to submit? This action cannot be undone.</p>
            <div class="flex justify-end space-x-3">
                <button id="modal-confirm-no" class="px-4 py-2 bg-gray-200 dark:bg-slate-600 text-gray-800 dark:text-slate-200 rounded-md hover:bg-gray-300 dark:hover:bg-slate-500 transition">Cancel</button>
                <button id="modal-confirm-yes" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition">Yes, Submit</button>
            </div>
        </div>
    </div>
    
    <!-- *** THIS IS THE NEW/EXPANDED FEEDBACK MODAL *** -->
    <div id="feedback-modal" class="modal-overlay hidden">
        <div class="modal-container dark:bg-slate-800 text-left" style="max-width: 600px; width: 95%;">
             <h2 class="text-2xl font-bold text-gray-800 dark:text-slate-100 mb-4">Mock Test Feedback</h2>
             <p class="text-gray-600 dark:text-slate-400 mb-6">Thank you for testing our application! Please provide your valuable feedback before you finish.</p>
             
             <!-- This form posts directly to Formspree -->
             <form id="feedback-form" action="https://formspree.io/f/xpwkaopb" method="POST">
                <div class="space-y-4">
                    <div>
                        <label for="feedback-name" class="block text-sm font-medium text-gray-700 dark:text-slate-300">Name</label>
                        <input type="text" id="feedback-name" name="Name" required class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100">
                    </div>
                    <div>
                        <label for="feedback-email" class="block text-sm font-medium text-gray-700 dark:text-slate-300">Email</label>
                        <input type="email" id="feedback-email" name="Email" required class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100">
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="feedback-ui" class="block text-sm font-medium text-gray-700 dark:text-slate-300">UI Rating (out of 5)</label>
                            <select id="feedback-ui" name="UI Rating" required class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100">
                                <option value="" disabled selected>Select a rating</option>
                                <option value="5">5 - Excellent</option>
                                <option value="4">4 - Good</option>
                                <option value="3">3 - Average</option>
                                <option value="2">2 - Poor</option>
                                <option value="1">1 - Very Poor</option>
                            </select>
                        </div>
                         <div>
                            <label for="feedback-ux" class="block text-sm font-medium text-gray-700 dark:text-slate-300">UX (User Experience) Rating</label>
                            <select id="feedback-ux" name="UX Rating" required class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100">
                                <option value="" disabled selected>Select a rating</option>
                                <option value="5">5 - Excellent</option>
                                <option value="4">4 - Good</option>
                                <option value="3">3 - Average</option>
                                <option value="2">2 - Poor</option>
                                <option value="1">1 - Very Poor</option>
                            </select>
                        </div>
                    </div>

                    <!-- === NEW FIELDS START === -->
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="feedback-experience" class="block text-sm font-medium text-gray-700 dark:text-slate-300">Overall Experience</label>
                            <select id="feedback-experience" name="Overall Experience" required class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100">
                                <option value="" disabled selected>Select a rating</option>
                                <option value="5">5 - Very Positive</option>
                                <option value="4">4 - Positive</option>
                                <option value="3">3 - Neutral</option>
                                <option value="2">2 - Negative</option>
                                <option value="1">1 - Very Negative</option>
                            </select>
                        </div>
                         <div>
                            <label for="feedback-bugs" class="block text-sm font-medium text-gray-700 dark:text-slate-300">Did you find any bugs?</label>
                            <select id="feedback-bugs" name="Bugs Encountered" required class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100">
                                <option value="" disabled selected>Select an option</option>
                                <option value="Yes">Yes</option>
                                <option value="No">No</option>
                            </select>
                        </div>
                    </div>

                    <div>
                        <label for="feedback-recommend" class="block text-sm font-medium text-gray-700 dark:text-slate-300">How likely are you to recommend this app? (0-10)</label>
                        <div class="flex justify-between text-xs text-gray-500 dark:text-slate-400 px-1 mt-2">
                            <span>Not Likely</span>
                            <span>Very Likely</span>
                        </div>
                        <input type="range" id="feedback-recommend" name="Likelihood to Recommend" min="0" max="10" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700" list="tickmarks">
                        <datalist id="tickmarks" class="flex justify-between w-full">
                            <option value="0" label="0"></option>
                            <option value="1"></option>
                            <option value="2"></option>
                            <option value="3"></option>
                            <option value="4"></option>
                            <option value="5" label="5"></option>
                            <option value="6"></option>
                            <option value="7"></option>
                            <option value="8"></option>
                            <option value="9"></option>
                            <option value="10" label="10"></option>
                        </datalist>
                    </div>
                    <!-- === NEW FIELDS END === -->
                    
                    <div>
                        <label for="feedback-comments" class="block text-sm font-medium text-gray-700 dark:text-slate-300">Comments or Bugs Found</label>
                        <textarea id="feedback-comments" name="Comments" rows="4" class="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-slate-100" placeholder="What did you like? What could be better? Did you find any bugs?"></textarea>
                    </div>

                    <!-- Formspree loading/error/success messages -->
                    <p id="feedback-status" class="text-sm font-medium text-center hidden"></p>
                </div>
                
                <div class="mt-8 flex justify-end space-x-3">
                    <button type="button" id="feedback-cancel-btn" class="px-6 py-2 bg-gray-200 dark:bg-slate-600 text-gray-800 dark:text-slate-200 font-semibold rounded-xl hover:bg-gray-300 dark:hover:bg-slate-500">Cancel</button>
                    <button type="submit" id="feedback-submit-btn" class="px-6 py-2 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 flex items-center">
                        <svg id="feedback-spinner" class="animate-spin -ml-1 mr-2 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <span id="feedback-submit-text">Submit Feedback</span>
                    </button>
                </div>
             </form>
        </div>
    </div>

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/placeholder/placeholder.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/edit/matchbrackets.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/edit/closebrackets.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/selection/active-line.js"></script>
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/placeholder/placeholder.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/edit/matchbrackets.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/edit/closebrackets.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/selection/active-line.js"></script>

    <!-- *** THIS IS THE ENTIRE JAVASCRIPT LOGIC FOR THE PAGE *** -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Dark Mode State ---
        let isDarkMode = localStorage.getItem('darkMode') === 'true';

        // --- DOM Element Refs ---
        const mainContent = document.getElementById('main-content');
        const testEnvironment = document.getElementById('test-environment');
        const loader = document.getElementById('loader');
        const errorMessageDiv = document.getElementById('error-message');
        
        // Header
        const testTitleHeader = document.getElementById('test-title-header');
        const problemTitleHeader = document.getElementById('problem-title-header');
        const timerTextEl = document.getElementById('timer-text');
        const timerFgCircle = document.getElementById('timer-fg');
        const timerLabel = document.getElementById('timer-label'); // NEW: Label for the timer (e.g., "SECTION TIME")
        const sectionTimerNote = document.getElementById('section-timer-note'); // NEW: Note for section timers
        const runCodeBtn = document.getElementById('run-code-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const runBtnText = document.getElementById('run-code-btn-text');
        const runSpinner = document.getElementById('run-spinner');
        const runIcon = document.getElementById('run-icon');
        const submitSpinner = document.getElementById('submit-spinner');
        const submitBtnText = document.getElementById('submit-btn-text');
        const submitIcon = document.getElementById('submit-icon');

        // Problems Sidebar (Off-canvas)
        const problemsSidebar = document.getElementById('problems-sidebar');
        const problemsOverlay = document.getElementById('problems-overlay');
        const toggleProblemsBtn = document.getElementById('toggle-problems-btn');
        const closeProblemsBtn = document.getElementById('close-problems-btn');
        const sectionNavigationContainer = document.getElementById('section-navigation-container');
        const totalTimerBlock = document.getElementById('total-timer-block'); // NEW: Total timer in sidebar
        const totalTimerText = document.getElementById('total-timer-text'); // NEW: Text for total timer

        // Left Panel (Problem Description)
        const problemTabContainer = document.querySelector('aside .flex-shrink-0');
        const problemTabContents = document.querySelectorAll('aside .problem-tab-content');
        const problemSpinner = document.getElementById('problem-spinner');
        const problemTitleMain = document.getElementById('problem-title-main').querySelector('span:last-child');
        const problemStatusMainDot = document.getElementById('problem-status-main-dot');
        const problemPointsBadge = document.getElementById('problem-points-badge');
        const problemDifficultyMain = document.getElementById('problem-difficulty-main');
        const problemDetailsContent = document.getElementById('problem-details-content');
        const scratchpad = document.getElementById('scratchpad');
        // REMOVED: Section info block references

        // Right Panel (Editor/Output)
        const languageSelect = document.getElementById('language-select');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const editorLockedOverlay = document.getElementById('editor-locked-overlay'); // NEW: Editor lock overlay
        const editorLockMessage = document.getElementById('editor-lock-message'); // NEW: Lock message
        const outputTabContainer = document.getElementById('output-tab-bar');
        const outputTabContents = document.querySelectorAll('main .output-tab-content');
        const resultsPlaceholder = document.getElementById('results-placeholder');
        const testCaseResultsContainer = document.getElementById('test-case-results');
        const outputConsole = document.getElementById('output-console');
        const outputPlaceholder = document.getElementById('output-placeholder');

        // Modals & Messages
        const messageBoxContainer = document.getElementById('message-box-container');
        const networkStatusIndicator = document.getElementById('network-status');
        const processingModal = document.getElementById('processing-modal');
        const processingSpinnerEl = document.getElementById('processing-spinner');
        const processingMessage = document.getElementById('processing-message');
        const processingErrorMessage = document.getElementById('processing-error-message');
        const confirmSubmitModal = document.getElementById('confirm-submit-modal');
        const modalConfirmYes = document.getElementById('modal-confirm-yes');
        const modalConfirmNo = document.getElementById('modal-confirm-no');
        const modalConfirmMessage = document.getElementById('modal-confirm-message');

        // Footer Year
        document.getElementById('current-year').textContent = new Date().getFullYear();


        // --- State Variables ---
        let token = null;
        let currentTest = null;
        let allProblemsFlat = []; // { problemId, title, score, sectionIndex, problemIndexInSection }
        let currentProblemGlobalIndex = -1;
        let problemSubmissions = {}; // { problemId: { code, language, evaluationResults } }
        let problemStatuses = []; // ['pending', 'attempted', 'solved']
        
        // --- NEW: Mock Test State ---
        let isMockTest = false; 

        // --- NEW: Timer State ---
        let totalTestTimerInterval = null; // For the *overall* test time
        let totalDurationSeconds = 0;
        let sectionTimerData = []; // [{ duration, remaining, interval, locked, title }]
        let activeSectionTimerIndex = -1; // Which section timer is currently active in the header
        
        let isSubmitting = false;
        let candidateDetails = {};
        let markdownConverter = new showdown.Converter({ tables: true, strikethrough: true, tasklists: true, simpleLineBreaks: true });
        let autosaveTimeout = null;
        const AUTOSAVE_DELAY = 3000;
        let currentAssignmentId = null;
        let currentTestId = null; 

        // --- HARDCODED BACKEND_URL ---
        const BACKEND_URL = 'https://www.testify-lac.com/';
        console.log(`[INIT] Using Local Test backend URL: ${BACKEND_URL}`);

        // --- CodeMirror Editor ---
        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            lineNumbers: true, mode: 'text/x-csrc', theme: isDarkMode ? 'material-darker' : 'neo',
            placeholder: 'Write your solution here...', indentUnit: 4, tabSize: 4, indentWithTabs: false,
            lineWrapping: true, matchBrackets: true, autoCloseBrackets: true, styleActiveLine: true
        });

        // --- Dark Mode ---
        function applyDarkMode(dark) {
             if (dark) {
                 document.documentElement.classList.add('dark');
                 themeIcon.classList.remove('fa-sun');
                 themeIcon.classList.add('fa-moon');
                 editor.setOption('theme', 'material-darker');
             } else {
                 document.documentElement.classList.remove('dark');
                 themeIcon.classList.remove('fa-moon');
                 themeIcon.classList.add('fa-sun');
                 editor.setOption('theme', 'neo');
             }
        }
        darkModeToggle.addEventListener('click', () => { isDarkMode = !isDarkMode; localStorage.setItem('darkMode', isDarkMode); applyDarkMode(isDarkMode); });
        applyDarkMode(isDarkMode);

        // --- Problems Sidebar Toggle ---
        function toggleProblemsSidebar() {
            const isOpen = problemsSidebar.classList.contains('translate-x-0');
            if (isOpen) {
                problemsSidebar.classList.remove('translate-x-0');
                problemsSidebar.classList.add('-translate-x-full');
                problemsOverlay.classList.remove('opacity-100', 'pointer-events-auto');
                problemsOverlay.classList.add('opacity-0', 'pointer-events-none');
            } else {
                problemsSidebar.classList.remove('-translate-x-full');
                problemsSidebar.classList.add('translate-x-0');
                problemsOverlay.classList.remove('opacity-0', 'pointer-events-none');
                problemsOverlay.classList.add('opacity-100', 'pointer-events-auto');
            }
        }
        toggleProblemsBtn.addEventListener('click', toggleProblemsSidebar);
        closeProblemsBtn.addEventListener('click', toggleProblemsSidebar);
        problemsOverlay.addEventListener('click', toggleProblemsSidebar);


        // --- Tab Switching Logic ---
         function setupTabs(container, contentSelector, activeClass, inactiveClass) {
             container.addEventListener('click', (e) => {
                 const tabButton = e.target.closest('button');
                 if (!tabButton || tabButton.classList.contains(activeClass.split(' ')[0])) return;
                 const tabName = tabButton.dataset.tab;
                 const contentElements = document.querySelectorAll(contentSelector);
                 container.querySelectorAll('button').forEach(btn => {
                     btn.classList.remove(...activeClass.split(' '));
                     btn.classList.add(...inactiveClass.split(' '));
                 });
                 tabButton.classList.add(...activeClass.split(' '));
                 tabButton.classList.remove(...inactiveClass.split(' '));
                 contentElements.forEach(content => {
                     content.classList.toggle('hidden', content.id !== `${tabName}-content`);
                 });
             });
         }
          setupTabs(problemTabContainer, 'aside .problem-tab-content', 'active-tab text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600 dark:border-indigo-400', 'inactive-tab text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-200');
          setupTabs(outputTabContainer, 'main .output-tab-content', 'active-tab text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600 dark:border-indigo-400', 'inactive-tab text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-200');


         // --- Utility Functions ---
        function showMessage(message, type = 'error', duration = 3000) {
             const box = document.createElement('div');
             box.textContent = message;
             box.className = `message-box ${type}`;
             messageBoxContainer.appendChild(box);
             requestAnimationFrame(() => { box.classList.add('show'); });
             setTimeout(() => {
                 box.classList.remove('show');
                 box.addEventListener('transitionend', () => box.remove(), { once: true });
             }, duration);
        }
        function showErrorOnMainScreen(message) {
             loader.classList.add('hidden');
             errorMessageDiv.classList.remove('hidden');
             errorMessageDiv.querySelector('p').textContent = message;
             console.error("UI ERROR DISPLAYED:", message);
        }
        function showProcessingModal(message = "Processing...") {
             processingMessage.textContent = message;
             processingErrorMessage.textContent = '';
             processingErrorMessage.classList.add('hidden');
             processingSpinnerEl.classList.remove('hidden');
             processingModal.classList.add('show');
        }
         function showProcessingSuccess(message = "Success!") {
             processingMessage.textContent = message;
             processingMessage.classList.remove('text-gray-700', 'dark:text-slate-300');
             processingMessage.classList.add('text-green-600', 'dark:text-green-400', 'font-semibold');
             processingErrorMessage.classList.add('hidden');
             processingSpinnerEl.classList.add('hidden');
         }
         function showProcessingError(message = "An error occurred.") {
             processingMessage.textContent = "Operation Failed";
             processingMessage.classList.remove('text-green-600', 'dark:text-green-400', 'font-semibold');
             processingMessage.classList.add('text-gray-700', 'dark:text-slate-300');
             processingErrorMessage.textContent = `Error: ${message}`;
             processingErrorMessage.classList.remove('hidden');
             processingSpinnerEl.classList.add('hidden');
         }
        function hideProcessingModal() {
             processingModal.classList.remove('show');
             // Reset text color
             processingMessage.classList.remove('text-green-600', 'dark:text-green-400', 'font-semibold');
             processingMessage.classList.add('text-gray-700', 'dark:text-slate-300');
        }
        function showConfirmModal(message) {
             return new Promise(resolve => {
                 modalConfirmMessage.textContent = message;
                 confirmSubmitModal.classList.add('show');
                 const resolveOnce = (value) => {
                     confirmSubmitModal.classList.remove('show');
                     modalConfirmYes.onclick = null;
                     modalConfirmNo.onclick = null;
                     resolve(value);
                 };
                 modalConfirmYes.onclick = () => resolveOnce(true);
                 modalConfirmNo.onclick = () => resolveOnce(false);
             });
        }
        function formatTime(seconds) {
            let mins = Math.floor(seconds / 60);
            let secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        function formatTotalTime(seconds) {
            let hrs = Math.floor(seconds / 3600);
            let mins = Math.floor((seconds % 3600) / 60);
            let secs = seconds % 60;
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        function sanitizeHTML(dirtyHtml) { return DOMPurify.sanitize(dirtyHtml, { USE_PROFILES: { html: true } }); }
        function markdownToHtml(md) { if (!md) return ''; try { const raw = markdownConverter.makeHtml(md); return sanitizeHTML(raw); } catch(e) { return sanitizeHTML(md); } }

        // --- Network Status Function ---
        function updateNetworkStatus() {
             const online = navigator.onLine;
             networkStatusIndicator.textContent = online ? 'Online' : 'Offline';
             // Remove all potential existing classes first
             networkStatusIndicator.classList.remove(
                 'bg-green-100', 'dark:bg-green-900', 'text-green-700', 'dark:text-green-300', 'border-green-300', 'dark:border-green-700',
                 'bg-red-100', 'dark:bg-red-900', 'text-red-700', 'dark:text-red-300', 'border-red-300', 'dark:border-red-700'
             );
             // Add the correct classes based on status and dark mode
             if (online) {
                 networkStatusIndicator.classList.add('bg-green-100', 'text-green-700', 'border-green-300');
                 if (isDarkMode) networkStatusIndicator.classList.add('dark:bg-green-900', 'dark:text-green-300', 'dark:border-green-700');
             } else {
                 networkStatusIndicator.classList.add('bg-red-100', 'text-red-700', 'border-red-300');
                 if (isDarkMode) networkStatusIndicator.classList.add('dark:bg-red-900', 'dark:text-red-300', 'dark:border-red-700');
             }
             networkStatusIndicator.style.opacity = '1';
             if (!online) { showMessage('You are offline. Code changes saved locally.', 'warning', 5000); }
             else { if (autosaveTimeout) { triggerAutosave(true); } } // Force save on reconnect
             setTimeout(() => { networkStatusIndicator.style.opacity = '0'; }, 4000);
        }

        // --- Autosave ---
        async function saveCodeSnippet(problemId, code, language) {
             if (isMockTest) {
                 console.log("[AUTOSAVE] Mock test. Skipping server save.");
                 return; // Don't autosave for mock tests
             }
             if (!navigator.onLine) {
                 console.log("[AUTOSAVE] Offline. Skipping server save.");
                 showMessage('Offline - Code saved locally.', 'info', 1500);
                 return;
             }
             if (!currentAssignmentId || !currentTestId) {
                 console.error("[AUTOSAVE ERROR] Missing critical IDs (assignmentId or testId). Cannot save to server.");
                 showMessage('Internal error: Cannot auto-save (missing IDs).', 'error');
                 return;
             }
             if (!token || !problemId || code === undefined || code === null || !language || language === "") {
                 console.warn("[AUTOSAVE] Invalid data or placeholder language. Saving locally only.");
                 return;
             }

             console.log(`[AUTOSAVE] Saving snippet for Problem: ${problemId}, Assignment: ${currentAssignmentId}, Test: ${currentTestId}, Lang: ${language}`);
             try {
                 const response = await fetch(`${BACKEND_URL}/api/public/save-code-snippet`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json', 'x-auth-token': token },
                     body: JSON.stringify({
                         assignmentId: currentAssignmentId,
                         testId: currentTestId, 
                         problemId: problemId,
                         code: code,
                         language: language
                     })
                 });

                 if (!response.ok) {
                     let errorMsg = `Server error (${response.status})`;
                     try {
                         const errorData = await response.json();
                         errorMsg = errorData.message || errorMsg;
                     } catch (jsonError) {
                         errorMsg = `Server error (${response.status}). Could not parse error response.`;
                         console.error("[AUTOSAVE] Error parsing backend error response:", await response.text());
                     }
                     console.error(`[AUTOSAVE SERVER ERROR] ${problemId}:`, response.status, errorMsg);
                     showMessage(`Auto-save failed: ${errorMsg}`, 'error');
                 } else {
                     console.log(`[AUTOSAVE] Success for ${problemId}`);
                 }
             } catch (error) { 
                 console.error(`[AUTOSAVE NETWORK/FETCH ERROR] ${problemId}:`, error);
                 if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                     showMessage('Network error during auto-save. Check connection.', 'warning');
                 } else {
                     showMessage(`Auto-save failed: ${error.message}`, 'error'); 
                 }
                 updateNetworkStatus();
             }
        }
        
        function triggerAutosave(forceSaveNow = false) {
            if (0 > currentProblemGlobalIndex || !allProblemsFlat[currentProblemGlobalIndex]) return;
            const problem = allProblemsFlat[currentProblemGlobalIndex];
            const problemId = problem.problemId;
            const currentCode = editor.getValue();
            const currentLanguage = languageSelect.value;
            
            problemSubmissions[problemId] = { ...(problemSubmissions[problemId] || {}), code: currentCode, language: currentLanguage };
            
            if (currentLanguage !== "" && currentCode.trim() !== '' && problemStatuses[currentProblemGlobalIndex] === 'pending') {
                problemStatuses[currentProblemGlobalIndex] = 'attempted';
                updateSectionNavigationUI();
                if(problemStatusMainDot) problemStatusMainDot.className = 'w-3 h-3 rounded-full bg-yellow-500 flex-shrink-0';
            }
            
            clearTimeout(autosaveTimeout);
            if (currentLanguage !== "") { 
                if (forceSaveNow) {
                    saveCodeSnippet(problemId, currentCode, currentLanguage);
                } else {
                    autosaveTimeout = setTimeout(() => saveCodeSnippet(problemId, currentCode, currentLanguage), AUTOSAVE_DELAY);
                }
            } else {
                console.log("[AUTOSAVE] Language not selected, saving locally only.");
            }
        }
        editor.on('change', () => triggerAutosave(false));


        // --- Scratchpad Autosave ---
        scratchpad.addEventListener('input', () => {
             if (0 > currentProblemGlobalIndex || !allProblemsFlat[currentProblemGlobalIndex]) return;
             const problemId = allProblemsFlat[currentProblemGlobalIndex].problemId;
             localStorage.setItem(`scratchpad_${problemId}`, scratchpad.value);
        });

        // --- Initialization ---
        async function initializeTest() {
             console.log('Coding Test Page: Initializing...');
             try {
                 // ---
                 // --- *** THIS IS THE FIX *** ---
                 // ---
                 // We now expect an object: { token: "...", isMockTest: true/false }
                 const tokenData = window.electronAPI ? await window.electronAPI.getValidatedToken() : null;
                 
                 if (!tokenData || !tokenData.token) {
                     // Handle the case for browser-based testing (if you still need it)
                     const urlToken = new URLSearchParams(window.location.search).get('token');
                     if (urlToken) {
                         token = urlToken;
                         isMockTest = false; // Assume not mock if token is from URL
                         console.warn("Running in browser mode or getValidatedToken failed, isMockTest set to false.");
                     } else {
                         throw new Error('Could not retrieve validated test token object.');
                     }
                 } else {
                     // This is the normal Electron flow
                     token = tokenData.token;
                     isMockTest = tokenData.isMockTest;
                 }
                 // ---
                 // --- *** END OF FIX *** ---
                 // ---
                 
                 console.log(`Coding Test Page: Received validated token. Is Mock: ${isMockTest}`);
                 
                 if (window.electronAPI?.onProctoringViolation) {
                     window.electronAPI.onProctoringViolation((message) => {
                         console.warn('[Proctoring Violation Received]:', message);
                         showMessage(`Warning: ${message}. Further violations may lead to submission.`, 'warning', 6000);
                     });
                     console.log("Proctoring violation listener attached.");
                 }
                 await fetchTestAndCandidateDetails();
             } catch (error) {
                 console.error('[InitializeTest Catch Block] Error during initialization:', error);
                 showErrorOnMainScreen(error.message || 'Failed to initialize the test environment.');
             }
        }

        // --- Fetch Test & Candidate Details ---
        async function fetchTestAndCandidateDetails() {
             if (!token) { showErrorOnMainScreen("Token error."); return; }
             console.log("Fetching test and candidate details...");
             loader.classList.remove('hidden'); errorMessageDiv.classList.add('hidden');

             try { 
                 // --- MODIFICATION: Only fetch candidate details if NOT a mock test ---
                 let candData = {};
                 const testResponse = await fetch(`${BACKEND_URL}/api/public/test-details`, { headers: { 'x-auth-token': token } });

                 const testData = await testResponse.json();
                 console.log("Raw Test Details Response:", { status: testResponse.status, ok: testResponse.ok, data: JSON.stringify(testData).substring(0, 500) + '...' });
                 if (!testResponse.ok) {
                      console.error("[FETCH ERROR] Failed to load test details:", testResponse.status, testData.message);
                      throw new Error(testData.message || `Failed to load test details (Status: ${testResponse.status})`);
                 }
                 currentTest = testData;
                 console.log("Fetched Test Details (currentTest):", JSON.stringify(currentTest).substring(0, 500) + '...'); 
                 
                 // --- Check if isMockTest flag is true from the test data itself ---
                 // This ensures our frontend state matches the backend-verified token state.
                 isMockTest = currentTest.isMockTest || false;
                 console.log(`[FETCH INFO] Confirmed isMockTest status from backend: ${isMockTest}`);


                 if (!isMockTest) {
                     // STANDARD HIRING FLOW: Fetch candidate details
                     console.log("Standard Flow: Fetching candidate details...");
                     const detailsResponse = await fetch(`${BACKEND_URL}/api/candidate-details`, { headers: { 'x-auth-token': token } });
                     const fetchedCandData = await detailsResponse.json();
                     console.log("Raw Candidate Details Response:", { status: detailsResponse.status, ok: detailsResponse.ok, data: fetchedCandData }); 
                     if (!detailsResponse.ok) {
                          console.error("[FETCH ERROR] Failed to fetch candidate details:", detailsResponse.status, fetchedCandData.message);
                         throw new Error(fetchedCandData.message || `Failed to fetch candidate details (Status: ${detailsResponse.status}). Ensure verification was completed.`);
                     }
                     candData = fetchedCandData;
                     console.log("Fetched Candidate Details:", candData);
                 } else {
                     // MOCK TEST FLOW: Use details submitted from verification page
                     console.log("Mock Flow: Using passed-through candidate details.");
                     try {
                         // This will fetch the 'init_' record we created in the verification step
                         const detailsResponse = await fetch(`${BACKEND_URL}/api/candidate-details`, { headers: { 'x-auth-token': token } });
                         if (detailsResponse.ok) {
                             candData = await detailsResponse.json();
                             console.log("Mock Flow: Successfully fetched passed-through candidate details:", candData);
                         } else {
                             // This might happen if the /api/candidate-details fails for a mock user (which it shouldn't anymore)
                             console.warn("Mock Flow: Could not get passed-through details, will use placeholders if needed.");
                             candData = { fullName: "Mock Tester", email: "mock@test.com" }; // Fallback
                         }
                     } catch (e) {
                         console.error("Mock Flow: Error fetching details (token may be invalid for this):", e.message);
                         candData = { fullName: "Mock Tester", email: "mock@test.com" }; // Fallback
                     }
                 }
                 candidateDetails = candData; // Set the global variable
                 // --- END MODIFICATION ---


                 currentAssignmentId = currentTest.assignmentId;
                 currentTestId = currentTest.codingTestId || currentTest.aptitudeTestId || currentTest.testId;
                 if (!currentAssignmentId || !currentTestId) {
                     console.error("[INIT ERROR] Missing assignmentId or testId in fetched test data. Autosave WILL FAIL.", currentTest);
                     // Don't show error for mock tests, as autosave is disabled
                     if (!isMockTest) {
                         showMessage("Configuration Error: Autosave cannot function correctly (missing IDs). Contact support.", "error", 10000);
                     }
                     // Don't disable buttons yet, problem loading might fix this
                 } else {
                     console.log(`[INIT INFO] Stored IDs for Autosave: Assignment=${currentAssignmentId}, Test=${currentTestId}`);
                 }


                 // --- FLATTEN PROBLEMS - WITH VALIDATION ---
                 allProblemsFlat = [];
                 console.log("[Flattening] Starting...");
                 if (!currentTest || !currentTest.sections || !Array.isArray(currentTest.sections)) {
                     console.error("[Flattening Error] 'sections' array is missing or invalid in test data:", JSON.stringify(currentTest)); 
                     throw new Error('Invalid test data format: Missing or invalid "sections" array.');
                 }
                 if (currentTest.sections.length === 0) {
                     console.warn("[Flattening Warn] 'sections' array is empty. No problems to display.");
                 } else {
                     currentTest.sections.forEach((section, secIndex) => {
                         console.log(`[Flattening] Processing Section ${secIndex}: "${section?.title}"`);
                         if (!section || !section.problems || !Array.isArray(section.problems)) {
                             console.warn(`[Flattening Warn] Section ${secIndex} ("${section?.title}") is missing 'problems' array or is invalid. Skipping section.`);
                             return; 
                         }
                         if (section.problems.length === 0) {
                             console.log(`[Flattening Info] Section ${secIndex} ("${section.title}") has 0 problems.`);
                             return; 
                         }
                         console.log(`[Flattening] Section ${secIndex} has ${section.problems.length} problems.`);
                         const problemsWithIndices = section.problems.map((p, probIndexInSection) => {
                             if (!p || !p.problemId || !p.title) {
                                 console.error(`[Flattening Error] Invalid problem structure (missing problemId or title) at Section ${secIndex}, Index ${probIndexInSection}:`, p);
                                 return null;
                             }
                             return { ...p, sectionIndex: secIndex, problemIndexInSection: probIndexInSection };
                         }).filter(p => p !== null); 
                         allProblemsFlat.push(...problemsWithIndices);
                     });
                 }
                 console.log(`[Flattening] Finished. Final Count: ${allProblemsFlat.length}`);
                 // --- END FLATTEN PROBLEMS ---

                 if (allProblemsFlat.length === 0) {
                     console.error("[Initialization Error] No valid problems were found after processing sections. Original sections data:", JSON.stringify(currentTest.sections));
                     throw new Error("Test contains no questions or invalid problem data.");
                 }

                 problemStatuses = new Array(allProblemsFlat.length).fill('pending');
                 problemSubmissions = {}; 
                 allProblemsFlat.forEach((p, i) => {
                     if (p && p.problemId) {
                         problemSubmissions[p.problemId] = { code: '', language: '', evaluationResults: null };
                     } else {
                         console.error(`[Init Error] Problem at flattened index ${i} is invalid after filtering (missing problemId):`, p);
                     }
                 });
                 console.log(`[Init] Initialized statuses (${problemStatuses.length}) & submissions map (${Object.keys(problemSubmissions).length} entries).`);

                 loader.classList.add('hidden');
                 try {
                  startTestEnvironment();
                 } catch (startError) {
                  console.error('[startTestEnvironment Error] Error during UI setup:', startError);
                  showErrorOnMainScreen('Error setting up the test interface: ' + startError.message);
                 }
            } catch (fetchError) { 
                console.error('[FETCH/PROCESS ERROR] Failed during fetchTestAndCandidateDetails:', fetchError);
                showErrorOnMainScreen(fetchError.message || 'Failed to load test or candidate data.');
            }
        }


        // --- Start Test UI ---
        function startTestEnvironment() {
             console.log("Starting test UI...");
             mainContent.classList.add('hidden');
             testEnvironment.classList.remove('hidden');
             testTitleHeader.textContent = currentTest?.title || 'Coding Test';
             
             // --- NEW: TIMER BRANCHING LOGIC ---
             if (currentTest.useSectionSettings) {
                 console.log("[TIMER] Using Section-Specific Timers.");
                 timerLabel.textContent = "SECTION TIME"; // Set header label
                 sectionTimerNote.classList.remove('hidden'); // Show "Section Based Timer Applied" note
                 totalTimerBlock.classList.remove('hidden'); // Show total timer in sidebar
                 
                 // Calculate total duration from all sections
                 totalDurationSeconds = currentTest.sections.reduce((total, sec) => total + (parseInt(sec.sectionTimer, 10) || 0), 0) * 60;
                 if (isNaN(totalDurationSeconds) || totalDurationSeconds <= 0) {
                     console.error("Invalid Section Durations. Total is 0.");
                     totalDurationSeconds = 0;
                 }
                 
                 initializeSectionTimers();
                 startTotalTestTimer(totalDurationSeconds);

             } else {
                 console.log("[TIMER] Using Global Timer.");
                 timerLabel.textContent = "TOTAL TIME"; // Set header label
                 sectionTimerNote.classList.add('hidden'); // Hide note
                 totalTimerBlock.classList.add('hidden'); // Hide sidebar timer
                 
                 totalDurationSeconds = parseInt(currentTest?.duration, 10) * 60;
                 if (isNaN(totalDurationSeconds) || totalDurationSeconds <= 0) {
                     console.error("Invalid Global Test Duration:", currentTest?.duration);
                     showErrorOnMainScreen("Configuration error: Invalid test duration.");
                     submitTestBtn.disabled = true; runCodeBtn.disabled = true; return;
                 }
                 startGlobalTimer(totalDurationSeconds); // Start the single global timer
             }
             // --- END TIMER BRANCH ---

             populateLanguages();
             updateSectionNavigationUI();
             if (allProblemsFlat.length > 0) {
                 const firstProblem = allProblemsFlat[0];
                 try {
                     if (firstProblem && typeof firstProblem.sectionIndex === 'number' && typeof firstProblem.problemIndexInSection === 'number') {
                         selectProblem(firstProblem.sectionIndex, firstProblem.problemIndexInSection);
                     } else {
                         console.error("StartTestEnvironment: Invalid indices for the first problem.", firstProblem);
                         throw new Error("Could not determine the first problem to load.");
                     }
                 } catch (selectError) {
                      console.error('[Initial SelectProblem Error] Failed to select first problem:', selectError);
                      showErrorOnMainScreen('Error loading the first problem: ' + selectError.message);
                      runCodeBtn.disabled = true; submitTestBtn.disabled = true; 
                 }
             } else {
                 problemDetailsContent.innerHTML = '<p class="text-center text-gray-500 dark:text-slate-400 italic mt-10">No problems available in this test.</p>';
                 runCodeBtn.disabled = true; submitTestBtn.disabled = true;
                 console.error("StartTestEnvironment: No problems found in allProblemsFlat. Cannot select first problem.");
             }
             setTimeout(() => { document.addEventListener('contextmenu', event => event.preventDefault()); }, 500);
        }

        // --- NEW/UPDATED TIMER FUNCTIONS ---
        
        // This timer runs the main circular clock in the header
        function startGlobalTimer(durationSeconds) {
             let timer = durationSeconds;
             clearInterval(totalTestTimerInterval);
             console.log(`[TIMER] Starting GLOBAL timer for ${timer}s`);
             
             const updateTimerDisplay = () => {
                 if (timer < 0) {
                     clearInterval(totalTestTimerInterval);
                     forceSubmitTest('Time Expired');
                     return;
                 }
                 timerTextEl.textContent = formatTime(timer); // Use MM:SS format
                 const progress = (durationSeconds - timer) / durationSeconds;
                 const dashOffset = 100 * (1 - progress);
                 timerFgCircle.style.strokeDashoffset = Math.max(0, Math.min(100, dashOffset));
                 
                 if (timer <= 60 && !timerTextEl.classList.contains('text-red-600')) {
                     timerTextEl.classList.add('text-red-600', 'dark:text-red-500', 'animate-pulse');
                     timerFgCircle.style.stroke = '#ef4444';
                 } else if (timer > 60 && timerTextEl.classList.contains('text-red-600')) {
                     timerTextEl.classList.remove('text-red-600', 'dark:text-red-500', 'animate-pulse');
                     timerFgCircle.style.stroke = isDarkMode ? '#818cf8' : '#4f46e5';
                 }
                 timer--;
             };
             updateTimerDisplay();
             totalTestTimerInterval = setInterval(updateTimerDisplay, 1000);
        }
        
        // This timer runs the *total* test timer in the sidebar
        function startTotalTestTimer(durationSeconds) {
            let timer = durationSeconds;
            clearInterval(totalTestTimerInterval);
            console.log(`[TIMER] Starting TOTAL (sidebar) timer for ${timer}s`);
            
            const updateTimerDisplay = () => {
                if (timer < 0) {
                    clearInterval(totalTestTimerInterval);
                    forceSubmitTest('Total Test Time Expired');
                    return;
                }
                totalTimerText.textContent = formatTotalTime(timer); // Use HH:MM:SS format
                timer--;
            };
            updateTimerDisplay();
            totalTestTimerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function initializeSectionTimers() {
            sectionTimerData = currentTest.sections.map((s, index) => {
                const duration = (parseInt(s.sectionTimer, 10) || 0) * 60;
                // totalDurationSeconds += duration; // This is already calculated
                return {
                    title: s.title || `Section ${index + 1}`,
                    duration: duration,
                    remaining: duration,
                    interval: null,
                    locked: false
                };
            });
            console.log("[TIMER] Section timers initialized:", sectionTimerData);
        }
        
        // This activates the *header* circular timer for a specific section
        function activateSectionTimer(sectionIndex) {
            if (activeSectionTimerIndex === sectionIndex || !currentTest.useSectionSettings) return;

            // Stop the old section timer
            if (activeSectionTimerIndex !== -1 && sectionTimerData[activeSectionTimerIndex] && sectionTimerData[activeSectionTimerIndex].interval) {
                console.log(`[TIMER] Stopping header timer for Section ${activeSectionTimerIndex}`);
                clearInterval(sectionTimerData[activeSectionTimerIndex].interval);
                sectionTimerData[activeSectionTimerIndex].interval = null;
            }
            
            activeSectionTimerIndex = sectionIndex;
            const timerData = sectionTimerData[activeSectionTimerIndex];
            if (!timerData) {
                 console.error(`[TIMER] No timer data for section ${activeSectionTimerIndex}`);
                 return;
            }

            console.log(`[TIMER] Activating header timer for Section ${activeSectionTimerIndex} ("${timerData.title}"). Remaining: ${timerData.remaining}s`);
            updateSectionTimerDisplay(); // Update display immediately

            if (timerData.locked) {
                console.log(`[TIMER] Section ${activeSectionTimerIndex} is already locked.`);
                timerTextEl.textContent = "00:00";
                timerFgCircle.style.strokeDashoffset = 100;
            } else if (!timerData.interval) {
                // Start the new interval
                timerData.interval = setInterval(() => {
                    timerData.remaining--;
                    updateSectionTimerDisplay();
                    if (timerData.remaining <= 0) {
                        lockSection(activeSectionTimerIndex);
                    }
                }, 1000);
            }
        }
        
        function updateSectionTimerDisplay() {
            if (activeSectionTimerIndex === -1) return;
            const timerData = sectionTimerData[activeSectionTimerIndex];
            
            timerTextEl.textContent = formatTime(timerData.remaining);
            const progress = (timerData.duration - timerData.remaining) / timerData.duration;
            const dashOffset = 100 * (1 - progress);
            timerFgCircle.style.strokeDashoffset = Math.max(0, Math.min(100, dashOffset));
            
            // Red alert for last minute
            if (timerData.remaining <= 60 && timerData.remaining > 0) {
                if (!timerTextEl.classList.contains('text-red-600')) {
                     timerTextEl.classList.add('text-red-600', 'dark:text-red-500', 'animate-pulse');
                     timerFgCircle.style.stroke = '#ef4444';
                }
            } else if (timerData.remaining > 60) {
                 timerTextEl.classList.remove('text-red-600', 'dark:text-red-500', 'animate-pulse');
                 timerFgCircle.style.stroke = isDarkMode ? '#818cf8' : '#4f46e5';
            } else if (timerData.remaining <= 0) {
                 // Timer finished, show 00:00 and red
                 timerTextEl.textContent = "00:00";
                 timerFgCircle.style.strokeDashoffset = 100;
                 timerTextEl.classList.add('text-red-600', 'dark:text-red-500');
                 timerTextEl.classList.remove('animate-pulse');
                 timerFgCircle.style.stroke = '#ef4444';
            }
        }

        function lockSection(sectionIndexToLock) {
            console.warn(`[TIMER] Locking Section ${sectionIndexToLock}!`);
            const timerData = sectionTimerData[sectionIndexToLock];
            if (!timerData || timerData.locked) return; // Already locked or invalid

            clearInterval(timerData.interval);
            timerData.interval = null;
            timerData.locked = true;
            timerData.remaining = 0;
            
            updateSectionNavigationUI(); // This will visually lock the section in the sidebar
            showMessage(`Time is up for "${timerData.title}". This section is now locked.`, "warning", 5000);

            // Check if the *currently viewed* problem is in the section that just got locked
            if (currentProblemGlobalIndex !== -1 && allProblemsFlat[currentProblemGlobalIndex].sectionIndex === sectionIndexToLock) {
                console.log(`[TIMER] Locking editor, as current problem is in expired section.`);
                editor.setOption("readOnly", "nocursor");
                editorLockMessage.textContent = `Time is up for "${timerData.title}".`;
                editorLockedOverlay.classList.remove('hidden');
            }
            
            // Check if all sections are now locked
            const allLocked = sectionTimerData.every(s => s.locked);
            if (allLocked) {
                 console.log("[TIMER] All section timers expired. Submitting test.");
                 forceSubmitTest('All section timers expired.');
            }
        }
        
         // --- UI Rendering ---
          function updateSectionNavigationUI() {
             if (!currentTest?.sections || !Array.isArray(currentTest.sections)) {
                 console.warn("[updateSectionNavUI] Cannot render: currentTest.sections is missing or invalid.");
                 sectionNavigationContainer.innerHTML = '<p class="text-xs text-center text-gray-400 dark:text-slate-500 py-4">Error loading sections.</p>';
                 return;
             }

             let globalProblemCounter = 0; 
             sectionNavigationContainer.innerHTML = currentTest.sections.map((section, sectionIndex) => {
                 if (!section || !Array.isArray(section.problems)) {
                     console.warn(`[updateSectionNavUI] Skipping invalid section structure at index ${sectionIndex}.`);
                     return '';
                 }
                 
                 const sectionState = currentTest.useSectionSettings ? sectionTimerData[sectionIndex] : null;
                 const isLocked = sectionState?.locked || false;
                 
                 const isOpen = sectionIndex === (allProblemsFlat[currentProblemGlobalIndex]?.sectionIndex ?? -1); 

                 const problemsHtml = section.problems.map((problem, problemIndexInSection) => {
                     const currentGlobalIndex = allProblemsFlat.findIndex(p => p.sectionIndex === sectionIndex && p.problemIndexInSection === problemIndexInSection);
                     if (currentGlobalIndex === -1) {
                          console.warn(`[updateSectionNavUI] Problem at S${sectionIndex}/P${problemIndexInSection} (Title: "${problem?.title}") not found in flattened list. Skipping button render.`);
                         return '';
                     }

                     const status = problemStatuses[currentGlobalIndex] || 'pending';
                     const isActive = currentGlobalIndex === currentProblemGlobalIndex;
                     const titleText = sanitizeHTML(problem.title || 'Untitled Problem');
                     globalProblemCounter++; 

                     // NEW: Add 'locked' class if section is locked
                     return `<li><button class="problem-nav-btn status-${status} ${isActive ? 'active' : ''} ${isLocked ? 'locked' : ''}" data-section-index="${sectionIndex}" data-problem-index="${problemIndexInSection}">P${globalProblemCounter}: ${titleText}</button></li>`;

                 }).join('');

                 if (problemsHtml.trim() === '') {
                     console.log(`[updateSectionNavUI] Section "${section.title}" has no valid problems to render.`);
                     return '';
                 }

                  const sectionTitleText = sanitizeHTML(section.title || 'Untitled Section');
                  
                  // NEW: Add section-specific timer info in sidebar
                  let sectionTimerHtml = '';
                  if (sectionState && sectionState.duration > 0) {
                      const timeStr = formatTime(sectionState.remaining);
                      sectionTimerHtml = `<span class="section-timer-info text-xs font-semibold tabular-nums ${isLocked ? 'locked' : 'text-indigo-600 dark:text-indigo-400'}">${isLocked ? 'Locked' : timeStr}</span>`;
                  }

                 return `<div class="section-container ${isOpen ? 'open' : ''}">
                            <div class="section-title flex justify-between items-center p-2 rounded hover:bg-gray-100 dark:hover:bg-slate-700" data-section-index="${sectionIndex}">
                                <span class="font-semibold text-sm text-gray-700 dark:text-slate-200">${sectionTitleText}</span>
                                <div class="flex items-center gap-2">
                                    ${sectionTimerHtml}
                                    <i class="chevron-icon fas fa-chevron-down text-xs text-gray-400 dark:text-slate-500 transition-transform"></i>
                                </div>
                            </div>
                            <ul class="section-problems-list pl-3 mt-1 space-y-1">${problemsHtml}</ul>
                        </div>`;

             }).join('');

             // Add event listeners after rendering
             sectionNavigationContainer.querySelectorAll('.section-title').forEach(titleEl => {
                 titleEl.addEventListener('click', () => titleEl.closest('.section-container').classList.toggle('open'));
             });
             sectionNavigationContainer.querySelectorAll('.problem-nav-btn').forEach(btn => {
                 btn.addEventListener('click', () => {
                     // NEW: Check if locked
                     if (btn.classList.contains('locked')) {
                         showMessage("This section is locked because its time has expired.", "warning");
                         return;
                     }
                     const secIdx = parseInt(btn.dataset.sectionIndex, 10);
                     const probIdxInSection = parseInt(btn.dataset.problemIndex, 10);
                     selectProblem(secIdx, probIdxInSection);
                     toggleProblemsSidebar(); // Close sidebar on selection
                 });
             });
          }

        // --- Select Problem ---
        async function selectProblem(sectionIndex, problemIndexInSection) {
             let globalIndex = -1; 
             let persistentProblemNumber = -1; 
             try {
                 globalIndex = allProblemsFlat.findIndex(p => p.sectionIndex === sectionIndex && p.problemIndexInSection === problemIndexInSection);
                 persistentProblemNumber = globalIndex + 1; 

                 if (globalIndex === -1) {
                     console.error(`[SELECT PROBLEM ERROR] Could not find global index for section ${sectionIndex}, problem ${problemIndexInSection}.`);
                     throw new Error(`Internal error: Problem mapping failed.`);
                 }
                 if (globalIndex === currentProblemGlobalIndex || isSubmitting) return;
                 console.log(`[SELECT PROBLEM] Switching to Global Index: ${globalIndex} (Persistent #: ${persistentProblemNumber}, Section ${sectionIndex}, ProblemInSection ${problemIndexInSection})`);

                 // --- Save State of Previous Problem ---
                 if (currentProblemGlobalIndex >= 0 && currentProblemGlobalIndex < allProblemsFlat.length && allProblemsFlat[currentProblemGlobalIndex]) {
                     const prevProblem = allProblemsFlat[currentProblemGlobalIndex];
                     const prevProblemId = prevProblem.problemId;
                     if (prevProblemId) { 
                         const prevCode = editor.getValue();
                         const prevLang = languageSelect.value;
                         console.log(`[SELECT] Saving state for previous problem ${prevProblemId}`);
                         problemSubmissions[prevProblemId] = { ...(problemSubmissions[prevProblemId] || {}), code: prevCode, language: prevLang };
                         if (prevLang !== "" && prevCode.trim() !== '' && problemStatuses[currentProblemGlobalIndex] === 'pending') {
                             problemStatuses[currentProblemGlobalIndex] = 'attempted';
                         }
                         clearTimeout(autosaveTimeout);
                         if (navigator.onLine && prevLang !== "") { 
                            await saveCodeSnippet(prevProblemId, prevCode, prevLang);
                         } else {
                              console.log(`[SELECT] Skipping immediate save for previous problem ${prevProblemId} (offline or no language). State saved locally.`);
                         }
                     } else {
                          console.warn(`[SELECT] Previous problem (index ${currentProblemGlobalIndex}) missing ID, cannot save state.`);
                     }
                 } else {
                     console.log(`[SELECT] No valid previous problem state to save (currentProblemGlobalIndex: ${currentProblemGlobalIndex}).`);
                 }
                 // --- End Save State ---

                 currentProblemGlobalIndex = globalIndex; 

                 // --- UI Updates for Loading State ---
                 problemDetailsContent.innerHTML = ''; 
                 problemSpinner.style.display = 'flex'; 
                 runCodeBtn.disabled = true; 
                 updateSectionNavigationUI(); 
                 resultsPlaceholder.style.display = 'flex';
                 resultsPlaceholder.textContent = 'Run code to see test case results here.';
                 testCaseResultsContainer.innerHTML = ''; testCaseResultsContainer.appendChild(resultsPlaceholder);
                 outputConsole.innerHTML = ''; outputPlaceholder.style.display = 'flex'; outputConsole.appendChild(outputPlaceholder);
                 // --- End Loading State ---

                 const problem = allProblemsFlat[currentProblemGlobalIndex]; 
                 if (!problem || !problem.problemId || !problem.title) {
                     console.error(`[SELECT PROBLEM ERROR] Invalid problem data at selected index ${currentProblemGlobalIndex}:`, problem);
                     throw new Error(`Internal error: Invalid problem data selected.`);
                 }
                 const problemId = problem.problemId;
                 console.log(`[SELECT] Loading problem ID: ${problemId}`);

                 // --- NEW: Activate Section Timer ---
                 if (currentTest.useSectionSettings) {
                     activateSectionTimer(problem.sectionIndex);
                     
                     // Check if this section is locked and lock the editor
                     if (sectionTimerData[problem.sectionIndex].locked) {
                         console.warn(`[SELECT] Editor is being locked for section ${problem.sectionIndex}.`);
                         editor.setOption("readOnly", "nocursor");
                         editorLockMessage.textContent = `Time is up for "${sectionTimerData[problem.sectionIndex].title}".`;
                         editorLockedOverlay.classList.remove('hidden');
                     } else {
                         editor.setOption("readOnly", false);
                         editorLockedOverlay.classList.add('hidden');
                     }
                 }
                 // --- END NEW ---

                 // --- Fetch Full Problem Details ---
                 let fullProblemData = {};
                 console.log(`[SELECT] Fetching full details for ${problemId}...`);
                  try {
                     const response = await fetch(`${BACKEND_URL}/api/public/problem-details/${problemId}`, { headers: { 'x-auth-token': token } });
                     if (!response.ok) {
                         const errorData = await response.json();
                         console.error(`[SELECT FETCH FAIL] Status: ${response.status}, Body:`, errorData);
                         throw new Error(errorData.message || `Server error (${response.status}) fetching problem details.`);
                     }
                     fullProblemData = await response.json(); 
                     console.log(`[SELECT] Fetched full details successfully.`);
                  } catch(fetchError) {
                      console.error(`[SELECT FETCH CATCH] Network or parsing error fetching problem ${problemId}:`, fetchError);
                      throw new Error(`Network error fetching problem details: ${fetchError.message}`);
                  }
                 // --- End Fetch Full Details ---

                 // --- Update UI with Problem Details ---
                 problemTitleHeader.textContent = `P${persistentProblemNumber}: ${sanitizeHTML(fullProblemData.title || 'Untitled')}`;
                 problemTitleMain.textContent = `P${persistentProblemNumber}: ${sanitizeHTML(fullProblemData.title || 'Untitled')}`;

                 const status = problemStatuses[currentProblemGlobalIndex] || 'pending';
                 problemStatusMainDot.className = 'w-3 h-3 rounded-full flex-shrink-0 '; 
                 if (status === 'solved') problemStatusMainDot.classList.add('bg-green-500');
                 else if (status === 'attempted') problemStatusMainDot.classList.add('bg-yellow-500');
                 else problemStatusMainDot.classList.add('bg-gray-400');

                 problemDifficultyMain.textContent = `${sanitizeHTML(fullProblemData.difficulty || 'N/A')}`;
                 if(fullProblemData.score) { problemPointsBadge.textContent = `${fullProblemData.score} pts`; problemPointsBadge.classList.remove('hidden'); }
                 else { problemPointsBadge.classList.add('hidden'); }
                 
                 problemDetailsContent.innerHTML = `
                     ${fullProblemData.description ? markdownToHtml(fullProblemData.description) : '<p>No description provided.</p>'}
                     ${fullProblemData.inputFormat ? `<h2>Input Format</h2>${markdownToHtml(fullProblemData.inputFormat)}` : ''}
                     ${fullProblemData.outputFormat ? `<h2>Output Format</h2>${markdownToHtml(fullProblemData.outputFormat)}` : ''}
                     ${fullProblemData.constraints ? `<h2>Constraints</h2><pre><code>${sanitizeHTML(fullProblemData.constraints)}</code></pre>` : ''}
                     ${fullProblemData.example ? `<h2>Example</h2><pre><code>${sanitizeHTML(fullProblemData.example)}</code></pre>` : ''}
                 `;
                 // --- End Update UI ---

                 // --- Load Saved Code/Language into Editor ---
                 const savedSubmission = problemSubmissions[problemId];
                 const savedCode = savedSubmission ? savedSubmission.code : '';
                 let savedLang = savedSubmission ? savedSubmission.language : '';

                 if (!languageSelect.querySelector(`option[value="${savedLang}"]`)) {
                     savedLang = ""; 
                 }
                 languageSelect.value = savedLang;

                 let editorContent = savedCode;
                 if (editorContent === '' && savedLang !== "" && fullProblemData.starterCode && fullProblemData.starterCode[savedLang]) {
                     editorContent = fullProblemData.starterCode[savedLang];
                      console.log(`[SELECT] Loaded starter code for ${savedLang}.`);
                 }
                 editor.setValue(editorContent);
                 languageSelect.dispatchEvent(new Event('change'));
                 // --- End Load Editor ---


                 // --- Load Scratchpad ---
                 scratchpad.value = localStorage.getItem(`scratchpad_${problemId}`) || '';
                 // --- End Load Scratchpad ---

                 problemSpinner.style.display = 'none'; 
                 runCodeBtn.disabled = (savedLang === "") || (currentTest.useSectionSettings && sectionTimerData[problem.sectionIndex].locked); // Also disable if section is locked

                 setTimeout(() => editor.refresh(), 1);

             } catch (error) {
                 console.error(`[SelectProblem Catch Block] Failed to load problem at index ${globalIndex}:`, error);
                 problemDetailsContent.innerHTML = `<p class="text-red-500 text-center p-4">Error loading problem details: ${error.message}. Please try selecting another problem or contact support.</p>`;
                 showMessage(`Error loading problem: ${error.message}`, 'error', 5000);
                 problemSpinner.style.display = 'none'; 
                 runCodeBtn.disabled = true; 
             }
        }


        // --- Populate Languages ---
        function populateLanguages() {
             const langs = { c: "C", cpp: "C++", java: "Java", python: "Python", javascript: "JavaScript" };
             languageSelect.innerHTML = `<option value="" disabled selected>-- Select Language --</option>` + Object.entries(langs).map(([v, t]) => `<option value="${v}">${t}</option>`).join('');
        }

        // --- Language Select Listener ---
        languageSelect.addEventListener('change', (e) => {
             const lang = e.target.value;
             console.log(`[LANG CHANGE] Switched to ${lang}`);
             
             // Check if run should be disabled
             const sectionLocked = currentTest.useSectionSettings && activeSectionTimerIndex !== -1 && sectionTimerData[activeSectionTimerIndex].locked;
             runCodeBtn.disabled = (lang === "") || sectionLocked;

             const modes = { python: 'python', java: 'text/x-java', c: 'text/x-csrc', cpp: 'text/x-c++src', javascript: 'javascript' };
             editor.setOption('mode', modes[lang] || 'text/plain');

             if (0 > currentProblemGlobalIndex || !allProblemsFlat[currentProblemGlobalIndex]) {
                 triggerAutosave(false); // Just save locally
                 return;
             }
             
             const problemId = allProblemsFlat[currentProblemGlobalIndex].problemId;
             const currentCode = editor.getValue();
             if (lang !== "" && currentCode.trim() === '') {
                 fetch(`${BACKEND_URL}/api/public/problem-details/${problemId}`, { headers: { 'x-auth-token': token } })
                     .then(res => res.ok ? res.json() : Promise.reject('Failed to fetch starter code'))
                     .then(fullProblemData => {
                          if (fullProblemData.starterCode && fullProblemData.starterCode[lang]) {
                             const starter = fullProblemData.starterCode[lang];
                             if (starter) {
                                  editor.setValue(starter);
                                  console.log(`[LANG CHANGE] Loaded starter code for ${lang}.`);
                             }
                         }
                         triggerAutosave(false); // Trigger autosave *after* starter code logic
                     })
                     .catch(err => {
                          console.error("[LANG CHANGE] Error fetching starter code:", err);
                          triggerAutosave(false);
                     });
             } else {
                 triggerAutosave(false);
             }
        });


          // --- Render Test Results ---
         function renderTestResults(results) {
             if (!results || results.length === 0) {
                 resultsPlaceholder.style.display = 'flex';
                 resultsPlaceholder.innerHTML = '<div class="flex items-center justify-center h-24 text-gray-500 dark:text-slate-400 italic">No results or execution failed.</div>';
                 testCaseResultsContainer.innerHTML = ''; testCaseResultsContainer.appendChild(resultsPlaceholder);
                 return;
             }
             resultsPlaceholder.style.display = 'none';
             const sanitize = (text) => { if (text == null) return ''; const temp = document.createElement('div'); temp.textContent = String(text); return temp.innerHTML; };
             testCaseResultsContainer.innerHTML = results.map((r, i) => {
                 let statusIcon, statusColorClass, bgColorClass;
                 const status = r && r.status ? r.status : 'Error'; 
                 switch (status) {
                     case 'Accepted':
                         statusIcon = 'fa-check-circle';
                         statusColorClass = 'text-green-700 dark:text-green-300';
                         bgColorClass = 'bg-green-50 dark:bg-green-900/40 border-green-200 dark:border-green-700';
                         break;
                     case 'Wrong Answer':
                         statusIcon = 'fa-times-circle';
                         statusColorClass = 'text-red-700 dark:text-red-300';
                         bgColorClass = 'bg-red-50 dark:bg-red-900/40 border-red-200 dark:border-red-700';
                         break;
                     default: // 'Error', 'Time Limit Exceeded', etc.
                         statusIcon = 'fa-exclamation-triangle';
                         statusColorClass = 'text-yellow-700 dark:text-yellow-300';
                         bgColorClass = 'bg-yellow-50 dark:bg-yellow-900/40 border-yellow-200 dark:border-yellow-700';
                         break;
                 }
                 let detailsHtml = '';
                 if (status === 'Wrong Answer') {
                     detailsHtml = `<div class="text-xs space-y-2 font-mono mt-2 pt-2 border-t border-gray-200 dark:border-slate-600"><p><strong class="text-gray-600 dark:text-slate-400">Input:</strong> <code class="bg-gray-100 dark:bg-slate-600 p-1 rounded whitespace-pre-wrap">${sanitize(r.input)}</code></p><p><strong class="text-gray-600 dark:text-slate-400">Expected:</strong> <code class="bg-gray-100 dark:bg-slate-600 p-1 rounded whitespace-pre-wrap">${sanitize(r.expected)}</code></p><p><strong class="text-gray-600 dark:text-slate-400">Your Output:</strong> <code class="bg-gray-100 dark:bg-slate-600 p-1 rounded whitespace-pre-wrap">${sanitize(r.actual)}</code></p></div>`;
                 } else if (status !== 'Accepted') { 
                     let errorMsg = sanitize(r.actual || r.stderr || r.message || 'No details available');
                     if (errorMsg.startsWith('Execution Error:') || errorMsg.startsWith('Compiler Service Error:')) {
                         errorMsg = errorMsg.substring(errorMsg.indexOf(':') + 1).trim();
                     }
                     detailsHtml = `<div class="text-xs space-y-2 font-mono mt-2 pt-2 border-t border-gray-200 dark:border-slate-600"><p class="text-gray-600 dark:text-slate-400"><strong>Details:</strong> <code class="bg-gray-100 dark:bg-slate-600 p-1 rounded whitespace-pre-wrap">${errorMsg}</code></p></div>`;
                 }
                  const timeDisplay = (r && typeof r.time === 'number') ? `${r.time.toFixed(3)}s` : (r && r.time ? r.time : 'N/A');
                 return `<div class="p-3 rounded-lg border ${bgColorClass}"><div class="flex justify-between items-center"><span class="font-semibold ${statusColorClass}"><i class="fas ${statusIcon} mr-2"></i>Case ${i + 1}: ${status}</span><span class="text-xs text-gray-500 dark:text-slate-400">${timeDisplay}</span></div>${detailsHtml}</div>`;
             }).join('');
         }


        // --- Code Execution ---
         runCodeBtn.addEventListener('click', async () => {
             if (isSubmitting || runCodeBtn.disabled || languageSelect.value === "") return;
             if (!navigator.onLine) {
                 showMessage("Cannot run code while offline.", "warning");
                 return;
             }
             if (0 > currentProblemGlobalIndex || !allProblemsFlat[currentProblemGlobalIndex]) {
                 showMessage("Please select a problem first.", "warning");
                 return;
             }
             
             // NEW: Final check for locked section
             const problem = allProblemsFlat[currentProblemGlobalIndex];
             if (currentTest.useSectionSettings && sectionTimerData[problem.sectionIndex].locked) {
                 showMessage("Cannot run code, time for this section has expired.", "error");
                 return;
             }
             
             let problemId, allResults = [], consoleOutput = '';
             let fetchedFullProblemData; 

             try {
                 problemId = problem.problemId;
                 console.log(`[RUN] Fetching full details for ${problemId} before execution...`);
                  try {
                     const response = await fetch(`${BACKEND_URL}/api/public/problem-details/${problemId}`, { headers: { 'x-auth-token': token } });
                     if (!response.ok) {
                         const errorData = await response.json(); throw new Error(errorData.message || `Server error (${response.status})`);
                     }
                     fetchedFullProblemData = await response.json(); 
                     console.log(`[RUN] Fetched full details successfully.`);
                  } catch(fetchError) {
                      throw new Error(`Network error fetching problem details: ${fetchError.message}`); 
                  }
                 if (!fetchedFullProblemData || !fetchedFullProblemData.testCases || !Array.isArray(fetchedFullProblemData.testCases) || fetchedFullProblemData.testCases.length === 0) {
                     console.error(`[RUN ERROR] No valid test cases found for ${problemId} after fetch.`);
                     throw new Error("Test cases for this problem could not be loaded or are missing.");
                 }
                 console.log(`[RUN] Evaluating ${problemId} (${fetchedFullProblemData.testCases.length} cases).`);

                 runCodeBtn.disabled = true; runBtnText.textContent = 'Running...'; runSpinner.classList.remove('hidden'); runIcon.classList.add('hidden');
                 outputTabContainer.querySelector('button[data-tab="testcases"]').click(); 
                 resultsPlaceholder.style.display = 'flex'; resultsPlaceholder.innerHTML = '<div class="flex items-center justify-center h-24 text-gray-500 dark:text-slate-400 italic animate-pulse">Running test cases...</div>';
                 testCaseResultsContainer.innerHTML = ''; outputConsole.innerHTML = ''; outputPlaceholder.style.display = 'flex'; outputConsole.appendChild(outputPlaceholder);

                 const language = languageSelect.value;
                 const code = editor.getValue();
                 if (language === "") throw new Error("Please select a language before running.");

                 await saveCodeSnippet(problemId, code, language); // Trigger save before run

                 for (let i = 0; i < fetchedFullProblemData.testCases.length; i++) {
                     const tc = fetchedFullProblemData.testCases[i];
                     console.log(`[RUN] Executing TC ${i + 1} for problem ${problemId}`);
                     try {
                          if (tc.input === undefined || tc.expected === undefined) {
                              console.warn(`[RUN WARN] Skipping invalid TC ${i + 1} (missing input/expected) for problem ${problemId}`);
                              allResults.push({ actual: 'Invalid Test Case Definition', status: 'Error', time: 'N/A' });
                              continue; 
                          }

                         const compileResponse = await fetch(`${BACKEND_URL}/api/compile`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'x-auth-token': token }, body: JSON.stringify({ language, code, input: tc.input }) });
                         const data = await compileResponse.json();

                         if (!compileResponse.ok || data.stderr || data.status === 'error' || (data.output && data.output.startsWith('Compiler Service Error:'))) {
                             let errorMsg = data.stderr || data.output || data.message || 'Unknown execution error';
                             console.error(`[RUN ERR] TC ${i + 1} Execution Error:`, errorMsg);
                             consoleOutput += `Case ${i+1} Error:\n${errorMsg}\n\n`; 
                             allResults.push({ input: tc.input, expected: tc.expected, actual: `Execution Error: ${errorMsg}`, status: 'Error', time: data.executionTime || 'N/A' }); 
                         } else {
                             const normalize = (str) => (str || '').toString().trim().replace(/\r\n/g, '\n').replace(/\s+$/, '');
                             const actual = normalize(data.output);
                             const expected = normalize(tc.expected);
                             const status = actual === expected ? 'Accepted' : 'Wrong Answer';
                             console.log(`[RUN] TC ${i+1} Status: ${status}. Expected: '${expected.substring(0,50)}...', Actual: '${actual.substring(0,50)}...'`);
                             consoleOutput += `Case ${i+1} Output:\n${data.output || '(No Output)'}\n\n`;
                             allResults.push({ input: tc.input, expected: tc.expected, actual: data.output || '', status, time: data.executionTime || 'N/A' });
                         }

                     } catch (execError) {
                         console.error(`[RUN ERR] TC ${i + 1} Network/Fetch failed:`, execError);
                         consoleOutput += `Case ${i+1} Network Error:\n${execError.message}\n\n`;
                         allResults.push({ input: tc.input, expected: tc.expected, actual: `Network Error: ${execError.message}`, status: 'Error', time: 'N/A' });
                     }
                 } 
                 console.log("[RUN] Evaluation completed.");

                 if (problemId) { 
                     problemSubmissions[problemId] = { ...(problemSubmissions[problemId] || {}), evaluationResults: allResults };
                 } else {
                     console.error("[RUN ERROR] Cannot save results, current problemId is invalid.");
                 }

                 const codeTrimmed = editor.getValue().trim();
                 if (allResults.length > 0) {
                     if (codeTrimmed === '') {
                         problemStatuses[currentProblemGlobalIndex] = 'pending';
                     } else if (allResults.every(r => r && r.status === 'Accepted')) { 
                         problemStatuses[currentProblemGlobalIndex] = 'solved';
                         showMessage(`Problem Solved!`, 'success'); 
                     } else {
                         problemStatuses[currentProblemGlobalIndex] = 'attempted';
                     }
                 } else if (codeTrimmed === '') {
                      problemStatuses[currentProblemGlobalIndex] = 'pending'; 
                 } 

                 console.log(`[RUN] Final Status for index ${currentProblemGlobalIndex}: ${problemStatuses[currentProblemGlobalIndex]}`);
                 updateSectionNavigationUI(); 

                 const newStatus = problemStatuses[currentProblemGlobalIndex];
                 problemStatusMainDot.className = 'w-3 h-3 rounded-full flex-shrink-0 '; 
                 if (newStatus === 'solved') problemStatusMainDot.classList.add('bg-green-500');
                 else if (newStatus === 'attempted') problemStatusMainDot.classList.add('bg-yellow-500');
                 else problemStatusMainDot.classList.add('bg-gray-400');

                 outputPlaceholder.style.display = 'none';
                 outputConsole.textContent = consoleOutput.trim() || 'No console output generated.'; 
                 renderTestResults(allResults); 

             } catch (error) {
                 console.error("[RUN FATAL]", error);
                 showMessage(`Execution failed: ${error.message}`, 'error');
                 renderTestResults([]); 
                 resultsPlaceholder.style.display = 'flex';
                 resultsPlaceholder.innerHTML = `<div class="flex items-center justify-center h-24 text-red-500 italic">Error during execution setup: ${error.message}</div>`;
                 outputPlaceholder.style.display = 'none';
                 outputConsole.textContent = `Setup Error: ${error.message}`;
             } finally {
                 console.log("[RUN] Re-enabling run button.");
                 const sectionLocked = currentTest.useSectionSettings && activeSectionTimerIndex !== -1 && sectionTimerData[activeSectionTimerIndex].locked;
                 runCodeBtn.disabled = (languageSelect.value === "") || sectionLocked;
                 runBtnText.textContent = 'Run';
                 runSpinner.classList.add('hidden');
                 runIcon.classList.remove('hidden');
             }
         });


        // --- Submission Logic ---
        async function forceSubmitTest(reason) {
             if (isSubmitting) return; 
             
             // --- NEW: Check for Mock Test ---
             if (isMockTest) {
                 console.log("Mock Test time expired. Opening feedback form.");
                 isSubmitting = true;
                 // Stop all timers
                 clearInterval(totalTestTimerInterval);
                 sectionTimerData.forEach(s => clearInterval(s.interval));
                 // Disable UI
                 submitTestBtn.disabled = true; runCodeBtn.disabled = true; editor.setOption("readOnly", "nocursor"); languageSelect.disabled = true;
                 // Show feedback
                 showFeedbackModal();
                 return; // Do not submit
             }
             // --- End Mock Test Check ---

             isSubmitting = true; 
             console.warn(`Force submitting. Reason: ${reason}`);
             // Clear all timers
             clearInterval(totalTestTimerInterval);
             sectionTimerData.forEach(s => clearInterval(s.interval));
             
             submitTestBtn.disabled = true; runCodeBtn.disabled = true; editor.setOption("readOnly", "nocursor"); languageSelect.disabled = true;
             sectionNavigationContainer.querySelectorAll('button').forEach(b => b.disabled = true);
             toggleProblemsBtn.disabled = true;
             showMessage(`Test ended: ${reason}. Submitting...`, 'error', 10000);
             await performSubmission(reason);
        }
        
        async function performSubmission(violationReason = null) {
             if (isSubmitting && !violationReason) return; 
             
             // --- NEW: Check for Mock Test ---
             if (isMockTest) {
                console.log("Mock Test submission blocked. Opening feedback form.");
                isSubmitting = true;
                submitTestBtn.disabled = true; runCodeBtn.disabled = true;
                showFeedbackModal();
                return; // Do not submit
             }
             // --- End Mock Test Check ---

             isSubmitting = true; 
             console.log(`[SUBMIT] Initiating. Reason: ${violationReason || 'Manual'}`);
             
             // --- Save State of Current Problem ---
             if (0 <= currentProblemGlobalIndex && currentProblemGlobalIndex < allProblemsFlat.length && allProblemsFlat[currentProblemGlobalIndex]) {
                 const currentProblem = allProblemsFlat[currentProblemGlobalIndex];
                 const currentProblemId = currentProblem.problemId;
                 if (currentProblemId) { 
                     const finalCode = editor.getValue();
                     let finalLang = languageSelect.value;
                     if (finalLang === "" && problemSubmissions[currentProblemId]?.language) {
                         finalLang = problemSubmissions[currentProblemId].language;
                     }
                     problemSubmissions[currentProblemId] = { ...(problemSubmissions[currentProblemId] || {}), code: finalCode, language: finalLang };
                     clearTimeout(autosaveTimeout); 
                     console.log(`[SUBMIT] Performing final save for current problem ${currentProblemId}...`);
                     if (navigator.onLine && finalLang !== "") { 
                         try {
                             await saveCodeSnippet(currentProblemId, finalCode, finalLang);
                             console.log(`[SUBMIT] Final save success for ${currentProblemId}.`);
                         }
                         catch (saveError) {
                              console.error(`[SUBMIT SAVE ERROR] Final save failed for ${currentProblemId}:`, saveError);
                             showMessage("Warning: Final code save failed before submission.", "warning");
                         }
                     } else {
                          console.log(`[SUBMIT] Skipping final save for ${currentProblemId} (offline or no language selected).`);
                     }
                 } else {
                     console.warn("[SUBMIT] Cannot perform final save: Current problem has no ID.");
                 }
             } else {
                 console.log("[SUBMIT] No current problem selected, skipping final save.");
             }
             // --- End Save State ---

             // --- Disable UI ---
             clearInterval(totalTestTimerInterval);
             sectionTimerData.forEach(s => clearInterval(s.interval));
             submitTestBtn.disabled = true; runCodeBtn.disabled = true; editor.setOption("readOnly", "nocursor"); languageSelect.disabled = true;
             sectionNavigationContainer.querySelectorAll('button').forEach(b => b.disabled = true);
             toggleProblemsBtn.disabled = true; 
             if (problemsSidebar.classList.contains('translate-x-0')) toggleProblemsSidebar(); 
             submitSpinner.classList.remove('hidden'); submitBtnText.textContent = 'Submitting...'; submitIcon.classList.add('hidden');
             showProcessingModal("Submitting solutions...");
             // --- End Disable UI ---

             // --- Prepare Payload ---
             const subsPayload = allProblemsFlat.map(problem => {
                 const problemId = problem.problemId;
                 if (!problemId) return null; 
                 const subData = problemSubmissions[problemId]; 
                 return (subData && subData.language && subData.language !== "")
                     ? {
                         problemId: problemId,
                         code: subData.code || '',
                         language: subData.language,
                         evaluationResults: subData.evaluationResults 
                       }
                     : null; 
             }).filter(sub => sub !== null); 

             if (!candidateDetails || !candidateDetails.fullName) {
                 console.error("[SUBMIT ERROR] Candidate details missing during payload preparation.");
                 showProcessingError("Critical Error: Candidate details missing. Cannot submit.");
                 submitSpinner.classList.add('hidden'); submitBtnText.textContent = 'Submit Failed'; submitIcon.classList.remove('hidden');
                 isSubmitting = false; 
                 return;
             }

             const finalPayload = {
                 submissions: subsPayload,
                 candidateDetails: candidateDetails, 
                 violationReason: violationReason
             };
             console.log("[SUBMIT] Final Payload prepared:", JSON.stringify(finalPayload).substring(0, 500) + "..."); 
             // --- End Prepare Payload ---


             // --- Send Submission ---
             try {
                 console.log("[SUBMIT] Sending submission to backend...");
                 const response = await fetch(`${BACKEND_URL}/api/public/submit-coding-test`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'x-auth-token': token }, body: JSON.stringify(finalPayload) });
                 const result = await response.json();
                 console.log("[SUBMIT] Backend Response:", { status: response.status, ok: response.ok, data: result });

                 if (!response.ok) {
                     throw new Error(result.message || `Submission failed (Status: ${response.status})`);
                 }

                 console.log("[SUBMIT] Success:", result.message);
                 showProcessingSuccess(result.message || 'Submitted successfully! You may close the application.');

                 if (window.electronAPI?.notifyTestSubmitted) {
                      window.electronAPI.notifyTestSubmitted();
                      console.log("[SUBMIT] Notified main Electron process of successful submission.");
                 } else {
                      console.warn("[SUBMIT] electronAPI not found. Cannot automatically close window.");
                      alert("Submission successful! You can now close this window.");
                 }
             } catch (error) {
                 console.error("[SUBMIT ERROR]", error);
                 showProcessingError(error.message || "Network error during submission.");
                 showMessage(`Submission Error: ${error.message}`, 'error', 10000);

                 // --- Re-enable UI on Failure ---
                 submitSpinner.classList.add('hidden'); submitBtnText.textContent = 'Submit Failed'; submitIcon.classList.remove('hidden');
                 submitTestBtn.disabled = false; // Allow retry
                 
                 // Re-enable run button only if language selected AND section not locked
                 const sectionLocked = currentTest.useSectionSettings && activeSectionTimerIndex !== -1 && sectionTimerData[activeSectionTimerIndex].locked;
                 runCodeBtn.disabled = (languageSelect.value === "") || sectionLocked;
                 
                 // Re-enable sidebar buttons that are NOT locked
                 sectionNavigationContainer.querySelectorAll('button').forEach(b => {
                     const secIdx = parseInt(b.dataset.sectionIndex, 10);
                     if (isNaN(secIdx) || !currentTest.useSectionSettings || !sectionTimerData[secIdx]?.locked) {
                         b.disabled = false;
                     }
                 });

                 toggleProblemsBtn.disabled = false; 
                 languageSelect.disabled = false;
                 editor.setOption("readOnly", sectionLocked); // Editor remains readOnly if section is locked
                 isSubmitting = false; // Allow retry
                 // --- End Re-enable UI ---
             }
             // --- End Send Submission ---
        }


        // --- NEW: Feedback Modal Logic (WITH FIX) ---
        function showFeedbackModal() {
            const modal = document.getElementById('feedback-modal');
            const form = document.getElementById('feedback-form');
            const statusEl = document.getElementById('feedback-status');
            const submitButton = document.getElementById('feedback-submit-btn');
            const submitText = document.getElementById('feedback-submit-text');
            const submitSpinner = document.getElementById('feedback-spinner');
            const cancelButton = document.getElementById('feedback-cancel-btn');

            // Try to pre-fill name and email from candidate details (if they exist)
            if (candidateDetails) {
                document.getElementById('feedback-name').value = candidateDetails.fullName || '';
                document.getElementById('feedback-email').value = candidateDetails.email || '';
            }

            modal.classList.remove('hidden');
            // *** THIS IS THE FIX ***
            // We use requestAnimationFrame to ensure the 'hidden' class is removed
            // before we add the 'show' class, triggering the transition.
            requestAnimationFrame(() => {
                modal.classList.add('show'); 
            });

            cancelButton.onclick = () => {
                modal.classList.remove('show'); // <-- THIS IS THE PAIRED FIX
                
                // Add a listener to re-hide it after the fade-out transition
                const onFadeOut = () => {
                    modal.classList.add('hidden');
                    modal.removeEventListener('transitionend', onFadeOut);
                };
                modal.addEventListener('transitionend', onFadeOut);

                // Re-enable submission in case they cancelled
                isSubmitting = false; 
                submitTestBtn.disabled = false;
            };

            form.onsubmit = async (e) => {
                e.preventDefault();
                submitButton.disabled = true;
                submitSpinner.classList.remove('hidden');
                submitText.textContent = 'Submitting...';
                statusEl.classList.add('hidden');

                const data = new FormData(form);
                try {
                    const response = await fetch(form.action, {
                        method: 'POST',
                        body: data,
                        headers: { 'Accept': 'application/json' }
                    });

                    if (response.ok) {
                        statusEl.textContent = 'Thank you for your feedback! The application will now close.';
                        statusEl.className = 'text-sm font-medium text-center text-green-600 dark:text-green-400';
                        statusEl.classList.remove('hidden');
                        
                        // Close the app after 3 seconds
                        setTimeout(() => {
                            if (window.electronAPI?.notifyTestSubmitted) {
                                window.electronAPI.notifyTestSubmitted();
                            } else {
                                alert("Feedback submitted. You can now close the window.");
                            }
                        }, 3000);

                    } else {
                        const result = await response.json();
                        let errorMsg = 'Could not submit feedback.';
                        if (result.errors) {
                            errorMsg = result.errors.map(err => err.message).join(', ');
                        }
                        throw new Error(errorMsg);
                    }
                } catch (error) {
                    statusEl.textContent = `Error: ${error.message}`;
                    statusEl.className = 'text-sm font-medium text-center text-red-600 dark:text-red-400';
                    statusEl.classList.remove('hidden');
                    submitButton.disabled = false;
                    submitSpinner.classList.add('hidden');
                    submitText.textContent = 'Submit Feedback';
                }
            };
        }
        // --- END: Feedback Modal Logic ---


        // --- Event Listeners ---
         submitTestBtn.addEventListener('click', async () => {
             console.log("[MANUAL SUBMIT] Clicked."); if (isSubmitting) return;
             
             // --- NEW: Check for Mock Test ---
             if (isMockTest) {
                await performSubmission(); // This will just open the modal
                return;
             }
             // --- End Mock Test Check ---

             const confirmed = await showConfirmModal("Are you sure you want to submit the test? You cannot make further changes after submission.");
             if (confirmed) { console.log("[MANUAL SUBMIT] Confirmed."); await performSubmission(); }
             else { console.log("[MANUAL SUBMIT] Cancelled."); }
        });
        document.addEventListener('contextmenu', event => event.preventDefault());
        window.addEventListener('online', updateNetworkStatus);
        window.addEventListener('offline', updateNetworkStatus);
        updateNetworkStatus();

        // --- Initial Call ---
        initializeTest();

    }); // End DOMContentLoaded
    </script>
</body>
</html>