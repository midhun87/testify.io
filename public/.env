BREVO_API_KEY=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


// ... other backend code and imports ...

/**
 * @route   GET /api/hiring/interview-report/:eventId
 * @desc    Moderator: Gets all evaluations for a specific event
 * @access  Private (Hiring Moderator)
 */
app.get('/api/hiring/interview-report/:eventId', hiringModeratorAuth, async (req, res) => {
    const { eventId } = req.params;

    try {
        // 1. Check if moderator owns this event
        const { Item: event } = await docClient.send(new GetCommand({
            TableName: HIRING_INTERVIEWS_TABLE,
            Key: { PK: eventId, SK: "METADATA" }
        }));
        if (!event || event.createdBy !== req.user.email) {
            return res.status(403).json({ message: "Access denied or event not found." });
        }

        // 2. Fetch all evaluations for this event using the GSI
        const { Items } = await docClient.send(new QueryCommand({
            TableName: HIRING_INTERVIEWS_TABLE,
            IndexName: "GSI1Index",
            KeyConditionExpression: "GSI1_PK = :pk",
            ExpressionAttributeValues: {
                ":pk": `REPORT#${eventId}`
            }
        }));

        // 3. Respond with the event metadata and the fetched evaluations
        res.json({
            eventId: event.eventId,
            eventName: event.eventName,
            jobTitle: event.jobTitle,
            createdAt: event.createdAt,
            evaluations: Items || []
        });

    } catch (error) {
        console.error(`Error fetching report for ${eventId}:`, error);
        res.status(500).json({ message: 'Server error fetching report.' });
    }
});


// =================================================================
// --- INTERVIEWER PORTAL ENDPOINTS ---
// =================================================================

// ... other interviewer endpoints like /my-schedule ...


/**
 * @route   GET /api/interviewer/slot-details/:slotId
 * @desc    Interviewer: Get details for a specific interview slot (candidate resume, photo, etc)
 * @access  Private (Interviewer)
 */
app.get('/api/interviewer/slot-details/:slotId', interviewerAuth, async (req, res) => {
    const { slotId } = req.params;
    const interviewerEmail = req.user.email;

    try {
        // 1. Fetch the slot (Ensuring GSI2Index is correct)
        const { Items } = await docClient.send(new QueryCommand({
            TableName: HIRING_INTERVIEWS_TABLE,
            IndexName: "GSI2Index", 
            KeyConditionExpression: "GSI2_PK = :sid",
            ExpressionAttributeValues: { ":sid": slotId }
        }));

        if (!Items || Items.length === 0) {
            return res.status(404).json({ message: "Slot not found." });
        }
        const slotData = Items[0];

        // 2. Security Check
        if (slotData.interviewerEmail !== interviewerEmail) {
            return res.status(403).json({ message: "Access denied. You are not assigned to this slot." });
        }

        // 3. Fetch the candidate's application (which has the resume)
        const { Items: applications } = await docClient.send(new QueryCommand({
            TableName: HIRING_APPLICATIONS_TABLE,
            IndexName: "email-jobId-index", // Use existing index
            KeyConditionExpression: "email = :email AND jobId = :jobId",
            ExpressionAttributeValues: {
                ":email": slotData.candidateEmail,
                ":jobId": slotData.jobId
            }
        }));

        let applicationData = {};
        if (applications && applications.length > 0) {
            applicationData = applications[0]; // Get the first matching application
        }
        
        // 4. Get Interviewer Photo (from their TestifyUsers profile)
        let interviewerPhotoUrl = null;
        try {
             const { Item: interviewer } = await docClient.send(new GetCommand({
                 TableName: "TestifyUsers",
                 Key: { email: interviewerEmail }
             }));
             if (interviewer && interviewer.profileImageUrl) {
                 interviewerPhotoUrl = interviewer.profileImageUrl;
             }
        } catch (e) { console.error("Could not fetch interviewer photo", e); }


        // --- CORRECTED RESPONSE ---
        // Send back all data needed to restore the interviewer's session
        res.json({
            slot: { ...slotData }, // Contains basic slot info
            application: applicationData, // Contains resumeUrl, etc.
            interviewerPhotoUrl: interviewerPhotoUrl,
            
            // State Restoration Data
            chatHistory: slotData.chatHistory || [],
            assignedProblems: slotData.assignedProblems || [], // So we can mark which are assigned
            latestCode: slotData.latestCode || '',
            latestLanguage: slotData.latestLanguage || 'javascript',
            currentProblemId: slotData.currentProblemId || null
        });

    } catch (error) {
        console.error(`Error fetching slot details ${slotId}:`, error);
        res.status(500).json({ message: 'Server error fetching slot details.' });
    }
});


// ... other backend code and endpoints ...
